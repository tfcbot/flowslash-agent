"use strict";
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tools = void 0;
const resource_1 = require("../core/resource.js");
const path_1 = require("../internal/utils/path.js");
class Tools extends resource_1.APIResource {
    /**
     * Retrieve detailed information about a specific tool using its slug identifier.
     * This endpoint returns full metadata about a tool including input/output
     * parameters, versions, and toolkit information.
     *
     * @example
     * ```ts
     * const tool = await client.tools.retrieve('tool_slug');
     * ```
     */
    retrieve(toolSlug, options) {
        return this._client.get((0, path_1.path) `/api/v3/tools/${toolSlug}`, options);
    }
    /**
     * Retrieve a paginated list of available tools with comprehensive filtering,
     * sorting and search capabilities. Use query parameters to narrow down results by
     * toolkit, tags, or search terms.
     *
     * @example
     * ```ts
     * const tools = await client.tools.list();
     * ```
     */
    list(query = {}, options) {
        return this._client.get('/api/v3/tools', { query, ...options });
    }
    /**
     * Execute a specific tool operation with provided arguments and authentication.
     * This is the primary endpoint for integrating with third-party services and
     * executing tools. You can provide structured arguments or use natural language
     * processing by providing a text description of what you want to accomplish.
     *
     * @example
     * ```ts
     * const response = await client.tools.execute('tool_slug');
     * ```
     */
    execute(toolSlug, body = {}, options) {
        return this._client.post((0, path_1.path) `/api/v3/tools/execute/${toolSlug}`, { body, ...options });
    }
    /**
     * Uses AI to translate a natural language description into structured arguments
     * for a specific tool. This endpoint is useful when you want to let users describe
     * what they want to do in plain language instead of providing structured
     * parameters.
     *
     * @example
     * ```ts
     * const response = await client.tools.getInput('tool_slug', {
     *   text: 'I need to trigger the main workflow in the octocat/Hello-World repository to deploy to production',
     * });
     * ```
     */
    getInput(toolSlug, body, options) {
        return this._client.post((0, path_1.path) `/api/v3/tools/execute/${toolSlug}/input`, { body, ...options });
    }
    /**
     * Proxy an HTTP request to a third-party API using connected account credentials.
     * This endpoint allows making authenticated API calls to external services while
     * abstracting away authentication details.
     *
     * @example
     * ```ts
     * const response = await client.tools.proxy({
     *   endpoint: '/api/v1/resources',
     *   method: 'GET',
     * });
     * ```
     */
    proxy(body, options) {
        return this._client.post('/api/v3/tools/execute/proxy', { body, ...options });
    }
    /**
     * Retrieve a list of all available tool enumeration values (tool slugs) for the
     * project. This endpoint returns a comma-separated string of tool slugs that can
     * be used in other API calls.
     *
     * @example
     * ```ts
     * const response = await client.tools.retrieveEnum();
     * ```
     */
    retrieveEnum(options) {
        return this._client.get('/api/v3/tools/enum', options);
    }
}
exports.Tools = Tools;
//# sourceMappingURL=tools.js.map