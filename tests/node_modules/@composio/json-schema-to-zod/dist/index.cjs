"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  jsonSchemaToZod: () => jsonSchemaToZod
});
module.exports = __toCommonJS(index_exports);

// src/parsers/parse-schema.ts
var z16 = __toESM(require("zod"), 1);

// src/parsers/parse-all-of.ts
var import_zod = require("zod");

// src/utils/half.ts
var half = (arr) => {
  return [arr.slice(0, arr.length / 2), arr.slice(arr.length / 2)];
};

// src/parsers/parse-all-of.ts
var originalIndex = Symbol("Original index");
var ensureOriginalIndex = (arr) => {
  const newArr = [];
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i];
    if (typeof item === "boolean") {
      newArr.push(item ? { [originalIndex]: i } : { [originalIndex]: i, not: {} });
    } else if (originalIndex in item) {
      return arr;
    } else {
      newArr.push({ ...item, [originalIndex]: i });
    }
  }
  return newArr;
};
function parseAllOf(jsonSchema, refs) {
  if (jsonSchema.allOf.length === 0) {
    return import_zod.z.never();
  }
  if (jsonSchema.allOf.length === 1) {
    const item = jsonSchema.allOf[0];
    return parseSchema(item, {
      ...refs,
      path: [...refs.path, "allOf", item[originalIndex]]
    });
  }
  const [left, right] = half(ensureOriginalIndex(jsonSchema.allOf));
  return import_zod.z.intersection(parseAllOf({ allOf: left }, refs), parseAllOf({ allOf: right }, refs));
}

// src/parsers/parse-any-of.ts
var import_zod2 = require("zod");
var parseAnyOf = (jsonSchema, refs) => {
  return jsonSchema.anyOf.length ? jsonSchema.anyOf.length === 1 ? parseSchema(jsonSchema.anyOf[0], {
    ...refs,
    path: [...refs.path, "anyOf", 0]
  }) : import_zod2.z.union(
    jsonSchema.anyOf.map(
      (schema, i) => parseSchema(schema, { ...refs, path: [...refs.path, "anyOf", i] })
    )
  ) : import_zod2.z.any();
};

// src/parsers/parse-array.ts
var import_zod3 = require("zod");

// src/utils/extend-schema.ts
function extendSchemaWithMessage(zodSchema, jsonSchema, key, extend) {
  const value = jsonSchema[key];
  if (value !== void 0) {
    const errorMessage = jsonSchema.errorMessage?.[key];
    return extend(zodSchema, value, errorMessage);
  }
  return zodSchema;
}

// src/utils/its.ts
var its = {
  an: {
    object: (x) => x.type === "object",
    array: (x) => x.type === "array",
    anyOf: (x) => x.anyOf !== void 0,
    allOf: (x) => x.allOf !== void 0,
    enum: (x) => x.enum !== void 0
  },
  a: {
    nullable: (x) => x.nullable === true,
    multipleType: (x) => Array.isArray(x.type),
    not: (x) => x.not !== void 0,
    const: (x) => x.const !== void 0,
    primitive: (x, p) => x.type === p,
    conditional: (x) => Boolean("if" in x && x.if && "then" in x && "else" in x && x.then && x.else),
    oneOf: (x) => x.oneOf !== void 0
  }
};

// src/parsers/parse-array.ts
var parseArray = (jsonSchema, refs) => {
  if (its.an.anyOf(jsonSchema)) {
    const types = /* @__PURE__ */ new Set();
    const itemsSchemas = [];
    jsonSchema.anyOf.forEach((option) => {
      if (typeof option === "object" && option.type) {
        types.add(typeof option.type === "string" ? option.type : option.type[0]);
      }
      if (typeof option === "object" && option.items) {
        const optionItems = option.items;
        if (!Array.isArray(optionItems) && typeof optionItems === "object") {
          itemsSchemas.push(optionItems);
        }
      }
    });
    let finalItems;
    if (itemsSchemas.length === 1) {
      finalItems = itemsSchemas[0];
    } else if (itemsSchemas.length > 1) {
      finalItems = { anyOf: itemsSchemas };
    }
    const newSchema = {
      ...types.size > 0 ? { type: Array.from(types) } : { type: "array" },
      ...finalItems && { items: finalItems }
    };
    const metadataFields = ["default", "description", "examples", "title"];
    metadataFields.forEach((field) => {
      const value = jsonSchema[field];
      if (value !== void 0) {
        newSchema[field] = value;
      }
    });
    return parseSchema(newSchema, refs);
  }
  if (Array.isArray(jsonSchema.items)) {
    return import_zod3.z.tuple(
      jsonSchema.items.map(
        (v, i) => parseSchema(v, { ...refs, path: [...refs.path, "items", i] })
      )
    );
  }
  let zodSchema = !jsonSchema.items ? import_zod3.z.array(import_zod3.z.any()) : import_zod3.z.array(parseSchema(jsonSchema.items, { ...refs, path: [...refs.path, "items"] }));
  zodSchema = extendSchemaWithMessage(
    zodSchema,
    jsonSchema,
    "minItems",
    (zs, minItems, errorMessage) => zs.min(minItems, errorMessage)
  );
  zodSchema = extendSchemaWithMessage(
    zodSchema,
    jsonSchema,
    "maxItems",
    (zs, maxItems, errorMessage) => zs.max(maxItems, errorMessage)
  );
  if (typeof jsonSchema.min === "number" && typeof jsonSchema.minItems !== "number") {
    zodSchema = extendSchemaWithMessage(
      zodSchema,
      { ...jsonSchema, minItems: jsonSchema.min },
      "minItems",
      (zs, minItems, errorMessage) => zs.min(minItems, errorMessage)
    );
  }
  if (typeof jsonSchema.max === "number" && typeof jsonSchema.maxItems !== "number") {
    zodSchema = extendSchemaWithMessage(
      zodSchema,
      { ...jsonSchema, maxItems: jsonSchema.max },
      "maxItems",
      (zs, maxItems, errorMessage) => zs.max(maxItems, errorMessage)
    );
  }
  return zodSchema;
};

// src/parsers/parse-boolean.ts
var import_zod4 = require("zod");
var parseBoolean = (_jsonSchema) => {
  return import_zod4.z.boolean();
};

// src/parsers/parse-const.ts
var import_zod5 = require("zod");
var parseConst = (jsonSchema) => {
  return import_zod5.z.literal(jsonSchema.const);
};

// src/parsers/parse-default.ts
var import_zod6 = require("zod");
var parseDefault = (_jsonSchema) => {
  return import_zod6.z.any();
};

// src/parsers/parse-enum.ts
var import_zod7 = require("zod");
var parseEnum = (jsonSchema) => {
  if (jsonSchema.enum.length === 0) {
    return import_zod7.z.never();
  }
  if (jsonSchema.enum.length === 1) {
    return import_zod7.z.literal(jsonSchema.enum[0]);
  }
  if (jsonSchema.enum.every((x) => typeof x === "string")) {
    return import_zod7.z.enum(jsonSchema.enum);
  }
  return import_zod7.z.union(
    jsonSchema.enum.map((x) => import_zod7.z.literal(x))
  );
};

// src/parsers/parse-if-then-else.ts
var import_zod8 = require("zod");
var parseIfThenElse = (jsonSchema, refs) => {
  const $if = parseSchema(jsonSchema.if, { ...refs, path: [...refs.path, "if"] });
  const $then = parseSchema(jsonSchema.then, {
    ...refs,
    path: [...refs.path, "then"]
  });
  const $else = parseSchema(jsonSchema.else, {
    ...refs,
    path: [...refs.path, "else"]
  });
  return import_zod8.z.union([$then, $else]).superRefine((value, ctx) => {
    const result = $if.safeParse(value).success ? $then.safeParse(value) : $else.safeParse(value);
    if (!result.success) {
      result.error.errors.forEach((error) => ctx.addIssue(error));
    }
  });
};

// src/parsers/parse-multiple-type.ts
var import_zod9 = require("zod");
var parseMultipleType = (jsonSchema, refs) => {
  return import_zod9.z.union(
    jsonSchema.type.map((type) => parseSchema({ ...jsonSchema, type }, refs))
  );
};

// src/parsers/parse-not.ts
var import_zod10 = require("zod");
var parseNot = (jsonSchema, refs) => {
  return import_zod10.z.any().refine(
    (value) => !parseSchema(jsonSchema.not, {
      ...refs,
      path: [...refs.path, "not"]
    }).safeParse(value).success,
    "Invalid input: Should NOT be valid against schema"
  );
};

// src/parsers/parse-null.ts
var import_zod11 = require("zod");
var parseNull = (_jsonSchema) => {
  return import_zod11.z.null();
};

// src/utils/omit.ts
var omit = (obj, ...keys) => Object.keys(obj).reduce((acc, key) => {
  if (!keys.includes(key)) {
    acc[key] = obj[key];
  }
  return acc;
}, {});

// src/parsers/parse-nullable.ts
var parseNullable = (jsonSchema, refs) => {
  return parseSchema(omit(jsonSchema, "nullable"), refs, true).nullable();
};

// src/parsers/parse-number.ts
var import_zod12 = require("zod");
var parseNumber = (jsonSchema) => {
  let zodSchema = import_zod12.z.number();
  let isInteger = false;
  if (jsonSchema.type === "integer") {
    isInteger = true;
    zodSchema = extendSchemaWithMessage(
      zodSchema,
      jsonSchema,
      "type",
      (zs, _, errorMsg) => zs.int(errorMsg)
    );
  } else if (jsonSchema.format === "int64") {
    isInteger = true;
    zodSchema = extendSchemaWithMessage(
      zodSchema,
      jsonSchema,
      "format",
      (zs, _, errorMsg) => zs.int(errorMsg)
    );
  }
  zodSchema = extendSchemaWithMessage(
    zodSchema,
    jsonSchema,
    "multipleOf",
    (zs, multipleOf, errorMsg) => {
      if (multipleOf === 1) {
        if (isInteger) return zs;
        return zs.int(errorMsg);
      }
      return zs.multipleOf(multipleOf, errorMsg);
    }
  );
  if (typeof jsonSchema.minimum === "number") {
    if (jsonSchema.exclusiveMinimum === true) {
      zodSchema = extendSchemaWithMessage(
        zodSchema,
        jsonSchema,
        "minimum",
        (zs, minimum, errorMsg) => zs.gt(minimum, errorMsg)
      );
    } else {
      zodSchema = extendSchemaWithMessage(
        zodSchema,
        jsonSchema,
        "minimum",
        (zs, minimum, errorMsg) => zs.gte(minimum, errorMsg)
      );
    }
  } else if (typeof jsonSchema.exclusiveMinimum === "number") {
    zodSchema = extendSchemaWithMessage(
      zodSchema,
      jsonSchema,
      "exclusiveMinimum",
      (zs, exclusiveMinimum, errorMsg) => zs.gt(exclusiveMinimum, errorMsg)
    );
  }
  if (typeof jsonSchema.maximum === "number") {
    if (jsonSchema.exclusiveMaximum === true) {
      zodSchema = extendSchemaWithMessage(
        zodSchema,
        jsonSchema,
        "maximum",
        (zs, maximum, errorMsg) => zs.lt(maximum, errorMsg)
      );
    } else {
      zodSchema = extendSchemaWithMessage(
        zodSchema,
        jsonSchema,
        "maximum",
        (zs, maximum, errorMsg) => zs.lte(maximum, errorMsg)
      );
    }
  } else if (typeof jsonSchema.exclusiveMaximum === "number") {
    zodSchema = extendSchemaWithMessage(
      zodSchema,
      jsonSchema,
      "exclusiveMaximum",
      (zs, exclusiveMaximum, errorMsg) => zs.lt(exclusiveMaximum, errorMsg)
    );
  }
  if (typeof jsonSchema.min === "number" && typeof jsonSchema.minimum !== "number") {
    zodSchema = extendSchemaWithMessage(
      zodSchema,
      { ...jsonSchema, minimum: jsonSchema.min },
      "minimum",
      (zs, minimum, errorMsg) => zs.gte(minimum, errorMsg)
    );
  }
  if (typeof jsonSchema.max === "number" && typeof jsonSchema.maximum !== "number") {
    zodSchema = extendSchemaWithMessage(
      zodSchema,
      { ...jsonSchema, maximum: jsonSchema.max },
      "maximum",
      (zs, maximum, errorMsg) => zs.lte(maximum, errorMsg)
    );
  }
  return zodSchema;
};

// src/parsers/parse-object.ts
var z14 = __toESM(require("zod"), 1);

// src/parsers/parse-one-of.ts
var import_zod13 = require("zod");
var parseOneOf = (jsonSchema, refs) => {
  if (!jsonSchema.oneOf.length) {
    return import_zod13.z.any();
  }
  if (jsonSchema.oneOf.length === 1) {
    return parseSchema(jsonSchema.oneOf[0], {
      ...refs,
      path: [...refs.path, "oneOf", 0]
    });
  }
  return import_zod13.z.any().superRefine((x, ctx) => {
    const schemas = jsonSchema.oneOf.map(
      (schema, i) => parseSchema(schema, {
        ...refs,
        path: [...refs.path, "oneOf", i]
      })
    );
    const unionErrors = schemas.reduce(
      (errors, schema) => ((result) => result.error ? [...errors, result.error] : errors)(schema.safeParse(x)),
      []
    );
    if (schemas.length - unionErrors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors,
        message: "Invalid input: Should pass single schema"
      });
    }
  });
};

// src/parsers/parse-object.ts
function parseObjectProperties(objectSchema, refs) {
  if (!objectSchema.properties) {
    return void 0;
  }
  const propertyKeys = Object.keys(objectSchema.properties);
  if (propertyKeys.length === 0) {
    return z14.object({});
  }
  const properties = {};
  for (const key of propertyKeys) {
    const propJsonSchema = objectSchema.properties[key];
    const propZodSchema = parseSchema(propJsonSchema, {
      ...refs,
      path: [...refs.path, "properties", key]
    });
    const required = Array.isArray(objectSchema.required) ? objectSchema.required.includes(key) : false;
    if (!required && propJsonSchema && typeof propJsonSchema === "object" && "default" in propJsonSchema) {
      if (propJsonSchema.default === null) {
        properties[key] = propZodSchema.nullable().optional().default(null);
      } else {
        properties[key] = propZodSchema.optional().default(propJsonSchema.default);
      }
    } else {
      properties[key] = required ? propZodSchema : propZodSchema.optional();
    }
  }
  return z14.object(properties);
}
function parseObject(objectSchema, refs) {
  const hasPatternProperties = Object.keys(objectSchema.patternProperties ?? {}).length > 0;
  const propertiesSchema = parseObjectProperties(objectSchema, refs);
  let zodSchema = propertiesSchema;
  const additionalProperties = objectSchema.additionalProperties !== void 0 ? parseSchema(objectSchema.additionalProperties, {
    ...refs,
    path: [...refs.path, "additionalProperties"]
  }) : void 0;
  if (objectSchema.patternProperties) {
    const parsedPatternProperties = Object.fromEntries(
      Object.entries(objectSchema.patternProperties).map(([key, value]) => {
        return [
          key,
          parseSchema(value, {
            ...refs,
            path: [...refs.path, "patternProperties", key]
          })
        ];
      })
    );
    const patternPropertyValues = Object.values(parsedPatternProperties);
    if (propertiesSchema) {
      if (additionalProperties) {
        zodSchema = propertiesSchema.catchall(
          z14.union([...patternPropertyValues, additionalProperties])
        );
      } else if (Object.keys(parsedPatternProperties).length > 1) {
        zodSchema = propertiesSchema.catchall(
          z14.union(patternPropertyValues)
        );
      } else {
        zodSchema = propertiesSchema.catchall(patternPropertyValues[0]);
      }
    } else {
      if (additionalProperties) {
        zodSchema = z14.record(
          z14.union([...patternPropertyValues, additionalProperties])
        );
      } else if (patternPropertyValues.length > 1) {
        zodSchema = z14.record(z14.union(patternPropertyValues));
      } else {
        zodSchema = z14.record(patternPropertyValues[0]);
      }
    }
    const objectPropertyKeys = new Set(Object.keys(objectSchema.properties ?? {}));
    zodSchema = zodSchema.superRefine((value, ctx) => {
      for (const key in value) {
        let wasMatched = objectPropertyKeys.has(key);
        for (const patternPropertyKey in objectSchema.patternProperties) {
          const regex = new RegExp(patternPropertyKey);
          if (key.match(regex)) {
            wasMatched = true;
            const result = parsedPatternProperties[patternPropertyKey].safeParse(value[key]);
            if (!result.success) {
              ctx.addIssue({
                path: [...ctx.path, key],
                code: "custom",
                message: `Invalid input: Key matching regex /${key}/ must match schema`,
                params: {
                  issues: result.error.issues
                }
              });
            }
          }
        }
        if (!wasMatched && additionalProperties) {
          const result = additionalProperties.safeParse(value[key]);
          if (!result.success) {
            ctx.addIssue({
              path: [...ctx.path, key],
              code: "custom",
              message: "Invalid input: must match catchall schema",
              params: {
                issues: result.error.issues
              }
            });
          }
        }
      }
    });
  }
  let output;
  if (propertiesSchema) {
    if (hasPatternProperties) {
      output = zodSchema;
    } else if (additionalProperties) {
      if (additionalProperties instanceof z14.ZodNever) {
        output = propertiesSchema.strict();
      } else {
        const isEmptyObject = Object.keys(propertiesSchema._def.shape()).length === 0;
        if (isEmptyObject) {
          output = propertiesSchema.passthrough();
        } else {
          output = propertiesSchema.catchall(additionalProperties);
        }
      }
    } else {
      output = propertiesSchema.passthrough();
    }
  } else {
    if (hasPatternProperties) {
      output = zodSchema;
    } else if (additionalProperties) {
      output = z14.record(additionalProperties);
    } else {
      output = z14.object({});
    }
  }
  if (its.an.anyOf(objectSchema)) {
    output = output.and(
      parseAnyOf(
        {
          ...objectSchema,
          anyOf: objectSchema.anyOf.map(
            (x) => typeof x === "object" && !x.type && (x.properties ?? x.additionalProperties ?? x.patternProperties) ? { ...x, type: "object" } : x
          )
        },
        refs
      )
    );
  }
  if (its.a.oneOf(objectSchema)) {
    output = output.and(
      parseOneOf(
        {
          ...objectSchema,
          oneOf: objectSchema.oneOf.map(
            (x) => typeof x === "object" && !x.type && (x.properties ?? x.additionalProperties ?? x.patternProperties) ? { ...x, type: "object" } : x
          )
        },
        refs
      )
    );
  }
  if (its.an.allOf(objectSchema)) {
    output = output.and(
      parseAllOf(
        {
          ...objectSchema,
          allOf: objectSchema.allOf.map(
            (x) => typeof x === "object" && !x.type && (x.properties ?? x.additionalProperties ?? x.patternProperties) ? { ...x, type: "object" } : x
          )
        },
        refs
      )
    );
  }
  return output;
}

// src/parsers/parse-string.ts
var import_zod14 = require("zod");
var parseString = (jsonSchema) => {
  let zodSchema = import_zod14.z.string();
  zodSchema = extendSchemaWithMessage(zodSchema, jsonSchema, "format", (zs, format, errorMsg) => {
    switch (format) {
      case "email":
        return zs.email(errorMsg);
      case "ip":
        return zs.ip(errorMsg);
      case "ipv4":
        return zs.ip({ version: "v4", message: errorMsg });
      case "ipv6":
        return zs.ip({ version: "v6", message: errorMsg });
      case "uri":
        return zs.url(errorMsg);
      case "uuid":
        return zs.uuid(errorMsg);
      case "date-time":
        return zs.datetime({ offset: true, message: errorMsg });
      case "time":
        return zs.time(errorMsg);
      case "date":
        return zs.date(errorMsg);
      case "binary":
        return zs.base64(errorMsg);
      case "duration":
        return zs.duration(errorMsg);
      default:
        return zs;
    }
  });
  zodSchema = extendSchemaWithMessage(
    zodSchema,
    jsonSchema,
    "contentEncoding",
    (zs, _, errorMsg) => zs.base64(errorMsg)
  );
  zodSchema = extendSchemaWithMessage(
    zodSchema,
    jsonSchema,
    "pattern",
    (zs, pattern, errorMsg) => zs.regex(new RegExp(pattern), errorMsg)
  );
  zodSchema = extendSchemaWithMessage(
    zodSchema,
    jsonSchema,
    "minLength",
    (zs, minLength, errorMsg) => zs.min(minLength, errorMsg)
  );
  zodSchema = extendSchemaWithMessage(
    zodSchema,
    jsonSchema,
    "maxLength",
    (zs, maxLength, errorMsg) => zs.max(maxLength, errorMsg)
  );
  if (typeof jsonSchema.min === "number" && typeof jsonSchema.minLength !== "number") {
    zodSchema = extendSchemaWithMessage(
      zodSchema,
      { ...jsonSchema, minLength: jsonSchema.min },
      "minLength",
      (zs, minLength, errorMsg) => zs.min(minLength, errorMsg)
    );
  }
  if (typeof jsonSchema.max === "number" && typeof jsonSchema.maxLength !== "number") {
    zodSchema = extendSchemaWithMessage(
      zodSchema,
      { ...jsonSchema, maxLength: jsonSchema.max },
      "maxLength",
      (zs, maxLength, errorMsg) => zs.max(maxLength, errorMsg)
    );
  }
  return zodSchema;
};

// src/parsers/parse-schema.ts
var addDescribes = (jsonSchema, zodSchema) => {
  let description = "";
  if (jsonSchema.description) {
    description = jsonSchema.description;
  } else if (jsonSchema.title) {
    description = jsonSchema.title;
  }
  if (jsonSchema.example !== void 0) {
    const exampleText = `Example: ${JSON.stringify(jsonSchema.example)}`;
    description = description ? `${description}
${exampleText}` : exampleText;
  } else if (jsonSchema.examples !== void 0 && Array.isArray(jsonSchema.examples)) {
    const examples = jsonSchema.examples;
    if (examples && examples.length && examples.length > 0) {
      const exampleText = examples.length === 1 ? `Example: ${JSON.stringify(examples[0])}` : `Examples:
${examples.map((ex) => `  ${JSON.stringify(ex)}`).join("\n")}`;
      description = description ? `${description}
${exampleText}` : exampleText;
    }
  }
  if (description) {
    zodSchema = zodSchema.describe(description);
  }
  return zodSchema;
};
var addDefaults = (jsonSchema, zodSchema) => {
  if (jsonSchema.default !== void 0) {
    zodSchema = zodSchema.default(jsonSchema.default);
  }
  return zodSchema;
};
var addAnnotations = (jsonSchema, zodSchema) => {
  if (jsonSchema.readOnly) {
    zodSchema = zodSchema.readonly();
  }
  return zodSchema;
};
var selectParser = (schema, refs) => {
  if (its.a.nullable(schema)) {
    return parseNullable(schema, refs);
  } else if (its.an.object(schema)) {
    return parseObject(schema, refs);
  } else if (its.an.array(schema)) {
    return parseArray(schema, refs);
  } else if (its.an.anyOf(schema)) {
    return parseAnyOf(schema, refs);
  } else if (its.an.allOf(schema)) {
    return parseAllOf(schema, refs);
  } else if (its.a.oneOf(schema)) {
    return parseOneOf(schema, refs);
  } else if (its.a.not(schema)) {
    return parseNot(schema, refs);
  } else if (its.an.enum(schema)) {
    return parseEnum(schema);
  } else if (its.a.const(schema)) {
    return parseConst(schema);
  } else if (its.a.multipleType(schema)) {
    return parseMultipleType(schema, refs);
  } else if (its.a.primitive(schema, "string")) {
    return parseString(schema);
  } else if (its.a.primitive(schema, "number") || its.a.primitive(schema, "integer")) {
    return parseNumber(schema);
  } else if (its.a.primitive(schema, "boolean")) {
    return parseBoolean(schema);
  } else if (its.a.primitive(schema, "null")) {
    return parseNull(schema);
  } else if (its.a.conditional(schema)) {
    return parseIfThenElse(schema, refs);
  } else {
    return parseDefault(schema);
  }
};
var parseSchema = (jsonSchema, refs = { seen: /* @__PURE__ */ new Map(), path: [] }, blockMeta) => {
  if (typeof jsonSchema !== "object") return jsonSchema ? z16.any() : z16.never();
  if (refs.parserOverride) {
    const custom = refs.parserOverride(jsonSchema, refs);
    if (custom instanceof z16.ZodType) {
      return custom;
    }
  }
  let seen = refs.seen.get(jsonSchema);
  if (seen) {
    if (seen.r !== void 0) {
      return seen.r;
    }
    if (refs.depth === void 0 || seen.n >= refs.depth) {
      return z16.any();
    }
    seen.n += 1;
  } else {
    seen = { r: void 0, n: 0 };
    refs.seen.set(jsonSchema, seen);
  }
  let parsedZodSchema = selectParser(jsonSchema, refs);
  if (!blockMeta) {
    if (!refs.withoutDescribes) {
      parsedZodSchema = addDescribes(jsonSchema, parsedZodSchema);
    }
    if (!refs.withoutDefaults) {
      parsedZodSchema = addDefaults(jsonSchema, parsedZodSchema);
    }
    parsedZodSchema = addAnnotations(jsonSchema, parsedZodSchema);
  }
  seen.r = parsedZodSchema;
  return parsedZodSchema;
};

// src/json-schema-to-zod.ts
var jsonSchemaToZod = (schema, options = {}) => {
  return parseSchema(schema, {
    path: [],
    seen: /* @__PURE__ */ new Map(),
    ...options
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  jsonSchemaToZod
});
