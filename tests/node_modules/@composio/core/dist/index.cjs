"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  AuthConfigCreationToolAccessConfigSchema: () => AuthConfigCreationToolAccessConfigSchema,
  AuthConfigErrorCodes: () => AuthConfigErrorCodes,
  AuthConfigListParamsSchema: () => AuthConfigListParamsSchema,
  AuthConfigListResponseSchema: () => AuthConfigListResponseSchema,
  AuthConfigRetrieveResponseSchema: () => AuthConfigRetrieveResponseSchema,
  AuthConfigToolAccessConfigSchema: () => AuthConfigToolAccessConfigSchema,
  AuthConfigTypes: () => AuthConfigTypes,
  AuthConfigUpdateParamsSchema: () => AuthConfigUpdateParamsSchema,
  AuthCustomConfigUpdateParamsSchema: () => AuthCustomConfigUpdateParamsSchema,
  AuthDefaultConfigUpdateParamsSchema: () => AuthDefaultConfigUpdateParamsSchema,
  AuthScheme: () => AuthScheme,
  AuthSchemeEnum: () => AuthSchemeEnum,
  AuthSchemeTypes: () => AuthSchemeTypes,
  BaseAgenticProvider: () => BaseAgenticProvider,
  BaseNonAgenticProvider: () => BaseNonAgenticProvider,
  BillcomAuthConnectionDataSchema: () => BillcomAuthConnectionDataSchema,
  Composio: () => Composio,
  ComposioAuthConfigNotFoundError: () => ComposioAuthConfigNotFoundError,
  ComposioConnectedAccountNotFoundError: () => ComposioConnectedAccountNotFoundError,
  ComposioCustomCreateResponseSchema: () => ComposioCustomCreateResponseSchema,
  ComposioCustomToolsNotInitializedError: () => ComposioCustomToolsNotInitializedError,
  ComposioError: () => ComposioError,
  ComposioGenerateURLParamsSchema: () => ComposioGenerateURLParamsSchema,
  ComposioGenerateURLResponseSchema: () => ComposioGenerateURLResponseSchema,
  ComposioGlobalExecuteToolFnNotSetError: () => ComposioGlobalExecuteToolFnNotSetError,
  ComposioInvalidExecuteFunctionError: () => ComposioInvalidExecuteFunctionError,
  ComposioInvalidModifierError: () => ComposioInvalidModifierError,
  ComposioLinkConnectionDataSchema: () => ComposioLinkConnectionDataSchema,
  ComposioMcpDeleteResponseSchema: () => ComposioMcpDeleteResponseSchema,
  ComposioMcpListResponseSchema: () => ComposioMcpListResponseSchema,
  ComposioMcpRetrieveResponseSchema: () => ComposioMcpRetrieveResponseSchema,
  ComposioMcpUpdateResponseSchema: () => ComposioMcpUpdateResponseSchema,
  ComposioMultipleConnectedAccountsError: () => ComposioMultipleConnectedAccountsError,
  ComposioNoAPIKeyError: () => ComposioNoAPIKeyError,
  ComposioProvider: () => ComposioProvider,
  ComposioProviderNotDefinedError: () => ComposioProviderNotDefinedError,
  ComposioToolExecutionError: () => ComposioToolExecutionError,
  ComposioToolNotFoundError: () => ComposioToolNotFoundError,
  ComposioToolkitFetchError: () => ComposioToolkitFetchError,
  ComposioToolkitNotFoundError: () => ComposioToolkitNotFoundError,
  ConnectedAccountAuthConfigSchema: () => ConnectedAccountAuthConfigSchema,
  ConnectedAccountErrorCodes: () => ConnectedAccountErrorCodes,
  ConnectedAccountListParamsSchema: () => ConnectedAccountListParamsSchema,
  ConnectedAccountListResponseSchema: () => ConnectedAccountListResponseSchema,
  ConnectedAccountRetrieveResponseSchema: () => ConnectedAccountRetrieveResponseSchema,
  ConnectedAccountStatusSchema: () => ConnectedAccountStatusSchema,
  ConnectedAccountStatuses: () => ConnectedAccountStatuses,
  ConnectionDataSchema: () => ConnectionDataSchema,
  ConnectionRequestErrorCodes: () => ConnectionRequestErrorCodes,
  ConnectionRequestFailedError: () => ConnectionRequestFailedError,
  ConnectionRequestTimeoutError: () => ConnectionRequestTimeoutError,
  ConnectionStatus: () => ConnectionStatus,
  ConnectionStatuses: () => ConnectionStatuses,
  CreateAuthConfigParamsSchema: () => CreateAuthConfigParamsSchema,
  CreateAuthConfigResponseSchema: () => CreateAuthConfigResponseSchema,
  CreateComposioManagedAuthConfigParamsSchema: () => CreateComposioManagedAuthConfigParamsSchema,
  CreateConnectedAccountOptionsSchema: () => CreateConnectedAccountOptionsSchema,
  CreateConnectedAccountParamsSchema: () => CreateConnectedAccountParamsSchema,
  CreateConnectedAccountResponseSchema: () => CreateConnectedAccountResponseSchema,
  CreateCustomAuthConfigParamsSchema: () => CreateCustomAuthConfigParamsSchema,
  CustomAuthParamsSchema: () => CustomAuthParamsSchema,
  CustomConnectionDataSchema: () => CustomConnectionDataSchema,
  CustomCreateResponseSchema: () => CustomCreateResponseSchema,
  CustomOauth1ConnectionDataSchema: () => CustomOauth1ConnectionDataSchema,
  CustomOauth2ConnectionDataSchema: () => CustomOauth2ConnectionDataSchema,
  DefaultCreateConnectedAccountParamsSchema: () => DefaultCreateConnectedAccountParamsSchema,
  GenerateURLParamsSchema: () => GenerateURLParamsSchema,
  GenerateURLResponseSchema: () => GenerateURLResponseSchema,
  IncomingTriggerPayloadSchema: () => IncomingTriggerPayloadSchema,
  JSONSchemaPropertySchema: () => JSONSchemaPropertySchema,
  JsonSchemaToZodError: () => JsonSchemaToZodError,
  MCP: () => MCP,
  MCPAuthOptionsSchema: () => MCPAuthOptionsSchema,
  MCPGenerateURLParamsSchema: () => MCPGenerateURLParamsSchema,
  MCPGetServerParamsSchema: () => MCPGetServerParamsSchema,
  MCPMultiAppServerSchema: () => MCPMultiAppServerSchema,
  MCPServerCreateResponseSchema: () => MCPServerCreateResponseSchema,
  MCPServerListResponseSchema: () => MCPServerListResponseSchema,
  MCPServerSchema: () => MCPServerSchema,
  MCPServerUpdateParamsSchema: () => MCPServerUpdateParamsSchema,
  MCPSingleAppServerSchema: () => MCPSingleAppServerSchema,
  MCPToolkitConfigSchema: () => MCPToolkitConfigSchema,
  MCPToolkitConfigsArraySchema: () => MCPToolkitConfigsArraySchema,
  McpDeleteResponseSchema: () => McpDeleteResponseSchema,
  McpListResponseSchema: () => McpListResponseSchema,
  McpRetrieveResponseSchema: () => McpRetrieveResponseSchema,
  McpUpdateResponseSchema: () => McpUpdateResponseSchema,
  Oauth1ActiveConnectionDataSchema: () => Oauth1ActiveConnectionDataSchema,
  Oauth1ConnectionDataSchema: () => Oauth1ConnectionDataSchema,
  Oauth1ExpiredConnectionDataSchema: () => Oauth1ExpiredConnectionDataSchema,
  Oauth1FailedConnectionDataSchema: () => Oauth1FailedConnectionDataSchema,
  Oauth1InactiveConnectionDataSchema: () => Oauth1InactiveConnectionDataSchema,
  Oauth1InitiatedConnectionDataSchema: () => Oauth1InitiatedConnectionDataSchema,
  Oauth1InitiatingConnectionDataSchema: () => Oauth1InitiatingConnectionDataSchema,
  Oauth2ActiveConnectionDataSchema: () => Oauth2ActiveConnectionDataSchema,
  Oauth2ConnectionDataSchema: () => Oauth2ConnectionDataSchema,
  Oauth2ExpiredConnectionDataSchema: () => Oauth2ExpiredConnectionDataSchema,
  Oauth2FailedConnectionDataSchema: () => Oauth2FailedConnectionDataSchema,
  Oauth2InactiveConnectionDataSchema: () => Oauth2InactiveConnectionDataSchema,
  Oauth2InitiatedConnectionDataSchema: () => Oauth2InitiatedConnectionDataSchema,
  Oauth2InitiatingConnectionDataSchema: () => Oauth2InitiatingConnectionDataSchema,
  OpenAIProvider: () => OpenAIProvider,
  RedirectableAuthSchemeSchema: () => RedirectableAuthSchemeSchema,
  SDKErrorCodes: () => SDKErrorCodes,
  ToolErrorCodes: () => ToolErrorCodes,
  ToolExecuteParamsSchema: () => ToolExecuteParamsSchema,
  ToolExecuteResponseSchema: () => ToolExecuteResponseSchema,
  ToolKitItemSchema: () => ToolKitItemSchema,
  ToolKitListResponseSchema: () => ToolKitListResponseSchema,
  ToolKitMetaSchema: () => ToolKitMetaSchema,
  ToolListParamsSchema: () => ToolListParamsSchema,
  ToolListResponseSchema: () => ToolListResponseSchema,
  ToolProxyParamsSchema: () => ToolProxyParamsSchema,
  ToolSchema: () => ToolSchema,
  ToolkitAuthConfigDetailsSchema: () => ToolkitAuthConfigDetailsSchema,
  ToolkitAuthFieldSchema: () => ToolkitAuthFieldSchema,
  ToolkitAuthFieldsResponseSchema: () => ToolkitAuthFieldsResponseSchema,
  ToolkitCategorySchema: () => ToolkitCategorySchema,
  ToolkitErrorCodes: () => ToolkitErrorCodes,
  ToolkitMangedByEnumSchema: () => ToolkitMangedByEnumSchema,
  ToolkitRetrieveCategoriesResponseSchema: () => ToolkitRetrieveCategoriesResponseSchema,
  ToolkitRetrieveResponseSchema: () => ToolkitRetrieveResponseSchema,
  ToolkitSchema: () => ToolkitSchema,
  ToolkitSortByEnumSchema: () => ToolkitSortByEnumSchema,
  ToolkitsListParamsSchema: () => ToolkitsListParamsSchema,
  TriggerInstanceListActiveParamsSchema: () => TriggerInstanceListActiveParamsSchema,
  TriggerInstanceListActiveResponseItemSchema: () => TriggerInstanceListActiveResponseItemSchema,
  TriggerInstanceListActiveResponseSchema: () => TriggerInstanceListActiveResponseSchema,
  TriggerInstanceManageDeleteResponseSchema: () => TriggerInstanceManageDeleteResponseSchema,
  TriggerInstanceManageUpdateParamsSchema: () => TriggerInstanceManageUpdateParamsSchema,
  TriggerInstanceManageUpdateResponseSchema: () => TriggerInstanceManageUpdateResponseSchema,
  TriggerInstanceUpsertParamsSchema: () => TriggerInstanceUpsertParamsSchema,
  TriggerInstanceUpsertResponseSchema: () => TriggerInstanceUpsertResponseSchema,
  TriggerStatusEnum: () => TriggerStatusEnum,
  TriggerStatuses: () => TriggerStatuses,
  TriggerSubscribeParamSchema: () => TriggerSubscribeParamSchema,
  TriggerTypeSchema: () => TriggerTypeSchema,
  TriggersTypeListParamsSchema: () => TriggersTypeListParamsSchema,
  TriggersTypeListResponseSchema: () => TriggersTypeListResponseSchema,
  ValidationError: () => ValidationError,
  ValidationErrorCodes: () => ValidationErrorCodes,
  constants: () => constants_exports,
  createConnectionRequest: () => createConnectionRequest,
  jsonSchemaToZodSchema: () => jsonSchemaToZodSchema,
  logger: () => logger_default,
  removeNonRequiredProperties: () => removeNonRequiredProperties
});
module.exports = __toCommonJS(index_exports);

// src/composio.ts
var import_client7 = __toESM(require("@composio/client"), 1);

// src/types/tool.types.ts
var import_zod3 = require("zod");

// src/types/connectedAccountAuthStates.types.ts
var import_zod2 = require("zod");

// src/types/authConfigs.types.ts
var import_zod = require("zod");
var AuthConfigTypes = {
  CUSTOM: "use_custom_auth",
  COMPOSIO_MANAGED: "use_composio_managed_auth"
};
var AuthSchemeTypes = {
  OAUTH1: "OAUTH1",
  OAUTH2: "OAUTH2",
  API_KEY: "API_KEY",
  BASIC: "BASIC",
  BEARER_TOKEN: "BEARER_TOKEN",
  BILLCOM_AUTH: "BILLCOM_AUTH",
  GOOGLE_SERVICE_ACCOUNT: "GOOGLE_SERVICE_ACCOUNT",
  NO_AUTH: "NO_AUTH",
  BASIC_WITH_JWT: "BASIC_WITH_JWT",
  COMPOSIO_LINK: "COMPOSIO_LINK",
  CALCOM_AUTH: "CALCOM_AUTH"
};
var AuthConfigCreationToolAccessConfigSchema = import_zod.z.object({
  toolsForConnectedAccountCreation: import_zod.z.array(import_zod.z.string()).optional()
});
var AuthConfigToolAccessConfigSchema = import_zod.z.object({
  toolsAvailableForExecution: import_zod.z.array(import_zod.z.string()).optional(),
  toolsForConnectedAccountCreation: import_zod.z.array(import_zod.z.string()).optional()
});
var AuthSchemeEnum = import_zod.z.enum([
  "OAUTH2",
  "OAUTH1",
  "API_KEY",
  "BASIC",
  "BILLCOM_AUTH",
  "BEARER_TOKEN",
  "GOOGLE_SERVICE_ACCOUNT",
  "NO_AUTH",
  "BASIC_WITH_JWT",
  "COMPOSIO_LINK",
  "CALCOM_AUTH"
]);
var CreateCustomAuthConfigParamsSchema = import_zod.z.object({
  type: import_zod.z.literal("use_custom_auth"),
  name: import_zod.z.string().optional(),
  credentials: import_zod.z.record(import_zod.z.string(), import_zod.z.union([import_zod.z.string(), import_zod.z.number(), import_zod.z.boolean()])),
  authScheme: AuthSchemeEnum,
  proxyConfig: import_zod.z.object({
    proxyUrl: import_zod.z.string(),
    proxyAuthKey: import_zod.z.string().optional()
  }).optional(),
  toolAccessConfig: AuthConfigCreationToolAccessConfigSchema.optional()
});
var CreateComposioManagedAuthConfigParamsSchema = import_zod.z.object({
  type: import_zod.z.literal("use_composio_managed_auth"),
  name: import_zod.z.string().optional(),
  credentials: import_zod.z.record(import_zod.z.string(), import_zod.z.union([import_zod.z.string(), import_zod.z.number(), import_zod.z.boolean()])).optional(),
  toolAccessConfig: AuthConfigCreationToolAccessConfigSchema.optional()
});
var CreateAuthConfigParamsSchema = import_zod.z.discriminatedUnion("type", [
  CreateCustomAuthConfigParamsSchema,
  CreateComposioManagedAuthConfigParamsSchema
]);
var CreateAuthConfigResponseSchema = import_zod.z.object({
  id: import_zod.z.string(),
  authScheme: import_zod.z.string(),
  isComposioManaged: import_zod.z.boolean(),
  toolkit: import_zod.z.string()
});
var AuthConfigRetrieveResponseSchema = import_zod.z.object({
  id: import_zod.z.string(),
  name: import_zod.z.string(),
  toolkit: import_zod.z.object({
    logo: import_zod.z.string(),
    slug: import_zod.z.string()
  }),
  noOfConnections: import_zod.z.number(),
  status: import_zod.z.enum(["ENABLED", "DISABLED"]),
  uuid: import_zod.z.string(),
  authScheme: AuthSchemeEnum.optional(),
  credentials: import_zod.z.record(import_zod.z.string(), import_zod.z.unknown()).optional(),
  expectedInputFields: import_zod.z.array(import_zod.z.unknown()).optional(),
  /**
   * @deprecated - use tool access config to determine the tools that the user can perform on the auth config.
   */
  restrictToFollowingTools: import_zod.z.array(import_zod.z.string()).optional(),
  isComposioManaged: import_zod.z.boolean().optional(),
  createdBy: import_zod.z.string().optional(),
  createdAt: import_zod.z.string().optional(),
  lastUpdatedAt: import_zod.z.string().optional(),
  toolAccessConfig: AuthConfigToolAccessConfigSchema.optional()
});
var AuthConfigListParamsSchema = import_zod.z.object({
  cursor: import_zod.z.string().optional(),
  isComposioManaged: import_zod.z.boolean().optional(),
  limit: import_zod.z.number().optional(),
  toolkit: import_zod.z.string().optional()
});
var AuthConfigListResponseSchema = import_zod.z.object({
  items: import_zod.z.array(AuthConfigRetrieveResponseSchema),
  nextCursor: import_zod.z.string().nullable(),
  totalPages: import_zod.z.number()
});
var AuthCustomConfigUpdateParamsSchema = import_zod.z.object({
  credentials: import_zod.z.record(import_zod.z.string(), import_zod.z.union([import_zod.z.string(), import_zod.z.unknown()])),
  type: import_zod.z.literal("custom"),
  /**
   * @deprecated - use tool access config to determine the tools that the user can perform on the auth config.
   */
  restrictToFollowingTools: import_zod.z.array(import_zod.z.string()).optional(),
  toolAccessConfig: AuthConfigToolAccessConfigSchema.optional()
});
var AuthDefaultConfigUpdateParamsSchema = import_zod.z.object({
  scopes: import_zod.z.string().optional(),
  type: import_zod.z.literal("default"),
  /**
   * @deprecated - use tool access config to determine the tools that the user can perform on the auth config.
   */
  restrictToFollowingTools: import_zod.z.array(import_zod.z.string()).optional(),
  toolAccessConfig: AuthConfigToolAccessConfigSchema.optional()
});
var AuthConfigUpdateParamsSchema = import_zod.z.discriminatedUnion("type", [
  AuthCustomConfigUpdateParamsSchema,
  AuthDefaultConfigUpdateParamsSchema
]);

// src/types/connectedAccountAuthStates.types.ts
var ConnectionStatuses = {
  INITIALIZING: "INITIALIZING",
  INITIATED: "INITIATED",
  ACTIVE: "ACTIVE",
  FAILED: "FAILED",
  EXPIRED: "EXPIRED",
  INACTIVE: "INACTIVE"
};
var RedirectableAuthSchemeSchema = import_zod2.z.enum([
  AuthSchemeTypes.OAUTH1,
  AuthSchemeTypes.OAUTH2,
  AuthSchemeTypes.COMPOSIO_LINK
]);
var BaseSchemeRaw = import_zod2.z.object({
  // for posthog, freshdesk, zendesk, clickup and others
  subdomain: import_zod2.z.string().optional(),
  // for atlassian
  ["your-domain"]: import_zod2.z.string().optional(),
  // for mixpanel
  region: import_zod2.z.string().optional(),
  // for shopify
  shop: import_zod2.z.string().optional(),
  // for snowflake
  account_url: import_zod2.z.string().optional(),
  // likely pipedrive
  COMPANYDOMAIN: import_zod2.z.string().optional(),
  // likely zoho
  extension: import_zod2.z.string().optional(),
  // likely formsite
  form_api_base_url: import_zod2.z.string().optional(),
  // likely salesforce
  instanceEndpoint: import_zod2.z.string().optional(),
  // likely active campaign
  api_url: import_zod2.z.string().optional(),
  // for borneo
  borneo_dashboard_url: import_zod2.z.string().optional(),
  // for zenrows proxy
  proxy_username: import_zod2.z.string().optional(),
  proxy_password: import_zod2.z.string().optional(),
  // for d2l
  domain: import_zod2.z.string().optional(),
  version: import_zod2.z.string().optional(),
  // for mailchimp
  dc: import_zod2.z.string().optional(),
  // for sharepoint
  site_name: import_zod2.z.string().optional(),
  // for servicenow
  instanceName: import_zod2.z.string().optional(),
  // for netsuite
  account_id: import_zod2.z.string().optional(),
  // for custom servers
  your_server: import_zod2.z.string().optional(),
  // for ragic
  server_location: import_zod2.z.string().optional(),
  // base_url only
  base_url: import_zod2.z.string().optional(),
  // for api key
  api_key: import_zod2.z.string().optional(),
  // for generic api key
  generic_api_key: import_zod2.z.string().optional(),
  // for bearer token
  bearer_token: import_zod2.z.string().optional()
}).catchall(import_zod2.z.unknown());
var Oauth2InitiatingConnectionDataSchema = BaseSchemeRaw.extend({
  status: import_zod2.z.literal(ConnectionStatuses.INITIALIZING)
}).catchall(import_zod2.z.unknown());
var Oauth2InitiatedConnectionDataSchema = Oauth2InitiatingConnectionDataSchema.extend({
  status: import_zod2.z.literal(ConnectionStatuses.INITIATED),
  code_verifier: import_zod2.z.string().optional(),
  redirectUrl: import_zod2.z.string(),
  callback_url: import_zod2.z.string().optional(),
  finalRedirectUri: import_zod2.z.string().optional(),
  // previously verification_token, will be sent as verification_token to slack
  webhook_signature: import_zod2.z.string().optional()
}).catchall(import_zod2.z.unknown());
var Oauth2ActiveConnectionDataSchema = Oauth2InitiatingConnectionDataSchema.extend({
  status: import_zod2.z.literal(ConnectionStatuses.ACTIVE),
  access_token: import_zod2.z.string().optional(),
  id_token: import_zod2.z.string().optional(),
  token_type: import_zod2.z.string().optional(),
  refresh_token: import_zod2.z.string().nullish(),
  expires_in: import_zod2.z.union([import_zod2.z.string(), import_zod2.z.number(), import_zod2.z.null()]).optional(),
  scope: import_zod2.z.union([import_zod2.z.string(), import_zod2.z.array(import_zod2.z.string()), import_zod2.z.null()]).optional(),
  // previously verification_token, will be sent as verification_token to slack
  webhook_signature: import_zod2.z.string().optional(),
  authed_user: import_zod2.z.object({
    access_token: import_zod2.z.string().optional(),
    scope: import_zod2.z.string().optional()
  }).optional().describe("for slack user scopes")
}).catchall(import_zod2.z.unknown());
var Oauth2FailedConnectionDataSchema = Oauth2InitiatingConnectionDataSchema.extend({
  status: import_zod2.z.literal(ConnectionStatuses.FAILED),
  error: import_zod2.z.string().optional(),
  error_description: import_zod2.z.string().optional()
}).catchall(import_zod2.z.unknown());
var Oauth2ExpiredConnectionDataSchema = Oauth2InitiatingConnectionDataSchema.extend({
  status: import_zod2.z.literal(ConnectionStatuses.EXPIRED),
  expired_at: import_zod2.z.string().optional()
}).catchall(import_zod2.z.unknown());
var Oauth2InactiveConnectionDataSchema = Oauth2InitiatingConnectionDataSchema.extend({
  status: import_zod2.z.literal(ConnectionStatuses.INACTIVE)
}).catchall(import_zod2.z.unknown());
var Oauth2ConnectionDataSchema = import_zod2.z.discriminatedUnion("status", [
  Oauth2InitiatingConnectionDataSchema,
  Oauth2InitiatedConnectionDataSchema,
  Oauth2ActiveConnectionDataSchema,
  Oauth2FailedConnectionDataSchema,
  Oauth2ExpiredConnectionDataSchema,
  Oauth2InactiveConnectionDataSchema
]);
var CustomOauth2ConnectionDataSchema = Oauth2ActiveConnectionDataSchema.omit({
  status: true,
  access_token: true
}).extend({
  access_token: import_zod2.z.string()
});
var Oauth1InitiatingConnectionDataSchema = BaseSchemeRaw.extend({
  status: import_zod2.z.literal(ConnectionStatuses.INITIALIZING)
}).catchall(import_zod2.z.unknown());
var Oauth1InitiatedConnectionDataSchema = Oauth1InitiatingConnectionDataSchema.extend({
  status: import_zod2.z.literal(ConnectionStatuses.INITIATED),
  oauth_token: import_zod2.z.string().optional(),
  authUri: import_zod2.z.string().optional(),
  oauth_token_secret: import_zod2.z.string().optional(),
  redirectUrl: import_zod2.z.string().optional(),
  callbackUrl: import_zod2.z.string().optional()
}).catchall(import_zod2.z.unknown());
var Oauth1ActiveConnectionDataSchema = Oauth1InitiatingConnectionDataSchema.extend({
  status: import_zod2.z.literal(ConnectionStatuses.ACTIVE),
  oauth_token: import_zod2.z.string().optional(),
  consumer_key: import_zod2.z.string().optional(),
  redirectUrl: import_zod2.z.string().optional(),
  callback_url: import_zod2.z.string().optional()
}).catchall(import_zod2.z.unknown());
var Oauth1FailedConnectionDataSchema = Oauth1InitiatingConnectionDataSchema.extend({
  status: import_zod2.z.literal(ConnectionStatuses.FAILED),
  error: import_zod2.z.string().optional(),
  error_description: import_zod2.z.string().optional()
}).catchall(import_zod2.z.unknown());
var Oauth1ExpiredConnectionDataSchema = Oauth1InitiatingConnectionDataSchema.extend({
  status: import_zod2.z.literal(ConnectionStatuses.EXPIRED),
  expired_at: import_zod2.z.string().optional()
}).catchall(import_zod2.z.unknown());
var Oauth1InactiveConnectionDataSchema = Oauth1InitiatingConnectionDataSchema.extend({
  status: import_zod2.z.literal(ConnectionStatuses.INACTIVE)
}).catchall(import_zod2.z.unknown());
var Oauth1ConnectionDataSchema = import_zod2.z.discriminatedUnion("status", [
  Oauth1InitiatingConnectionDataSchema,
  Oauth1InitiatedConnectionDataSchema,
  Oauth1ActiveConnectionDataSchema,
  Oauth1FailedConnectionDataSchema,
  Oauth1ExpiredConnectionDataSchema,
  Oauth1InactiveConnectionDataSchema
]);
var CustomOauth1ConnectionDataSchema = Oauth1ActiveConnectionDataSchema.omit({
  status: true,
  oauth_token: true
}).extend({
  oauth_token_secret: import_zod2.z.string(),
  oauth_token: import_zod2.z.string()
});
var ComposioLinkInitiatingSchema = BaseSchemeRaw.extend({
  status: import_zod2.z.literal(ConnectionStatuses.INITIALIZING)
}).catchall(import_zod2.z.unknown());
var ComposioLinkConnectionDataSchema = import_zod2.z.discriminatedUnion("status", [
  ComposioLinkInitiatingSchema,
  ComposioLinkInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.INITIATED),
    redirectUrl: import_zod2.z.string()
  }).catchall(import_zod2.z.unknown()),
  ComposioLinkInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.ACTIVE)
  }).catchall(import_zod2.z.unknown()),
  ComposioLinkInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.FAILED),
    error: import_zod2.z.string().optional(),
    error_description: import_zod2.z.string().optional()
  }).catchall(import_zod2.z.unknown()),
  ComposioLinkInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.EXPIRED),
    expired_at: import_zod2.z.string().optional()
  }).catchall(import_zod2.z.unknown()),
  ComposioLinkInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.INACTIVE)
  }).catchall(import_zod2.z.unknown())
]);
var BillcomAuthInitiatingSchema = BaseSchemeRaw.extend({
  status: import_zod2.z.literal(ConnectionStatuses.INITIALIZING)
}).catchall(import_zod2.z.unknown());
var BillcomAuthConnectionDataSchema = import_zod2.z.discriminatedUnion("status", [
  BillcomAuthInitiatingSchema,
  BillcomAuthInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.INITIATED),
    redirectUrl: import_zod2.z.string()
  }).catchall(import_zod2.z.unknown()),
  BillcomAuthInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.ACTIVE),
    sessionId: import_zod2.z.string(),
    devKey: import_zod2.z.string()
  }).catchall(import_zod2.z.unknown()),
  BillcomAuthInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.FAILED),
    error: import_zod2.z.string().optional(),
    error_description: import_zod2.z.string().optional()
  }).catchall(import_zod2.z.unknown()),
  BillcomAuthInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.EXPIRED),
    expired_at: import_zod2.z.string().optional()
  }).catchall(import_zod2.z.unknown()),
  BillcomAuthInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.INACTIVE)
  }).catchall(import_zod2.z.unknown())
]);
var BasicInitiatingSchema = BaseSchemeRaw.extend({
  status: import_zod2.z.literal(ConnectionStatuses.ACTIVE),
  username: import_zod2.z.string(),
  password: import_zod2.z.string()
}).catchall(import_zod2.z.unknown());
var BasicConnectionDataSchema = import_zod2.z.discriminatedUnion("status", [
  BasicInitiatingSchema,
  BasicInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.INACTIVE)
  }).catchall(import_zod2.z.unknown()),
  BasicInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.FAILED),
    error: import_zod2.z.string().optional(),
    error_description: import_zod2.z.string().optional()
  }).catchall(import_zod2.z.unknown()),
  BasicInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.EXPIRED),
    expired_at: import_zod2.z.string().optional()
  }).catchall(import_zod2.z.unknown())
]);
var CustomBasicConnectionDataSchema = BasicInitiatingSchema.omit({
  status: true
});
var ApiKeyInitiatingSchema = BaseSchemeRaw.extend({
  status: import_zod2.z.literal(ConnectionStatuses.ACTIVE),
  api_key: import_zod2.z.string().optional(),
  generic_api_key: import_zod2.z.string().optional()
}).catchall(import_zod2.z.unknown());
var ApiKeyConnectionDataSchema = import_zod2.z.discriminatedUnion("status", [
  ApiKeyInitiatingSchema,
  ApiKeyInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.INACTIVE)
  }).catchall(import_zod2.z.unknown()),
  ApiKeyInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.FAILED),
    error: import_zod2.z.string().optional(),
    error_description: import_zod2.z.string().optional()
  }).catchall(import_zod2.z.unknown()),
  ApiKeyInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.EXPIRED),
    expired_at: import_zod2.z.string().optional()
  }).catchall(import_zod2.z.unknown())
]);
var CustomApiKeyConnectionDataSchema = ApiKeyInitiatingSchema.omit({
  status: true
});
var BearerTokenInitiatingSchema = BaseSchemeRaw.extend({
  status: import_zod2.z.literal(ConnectionStatuses.ACTIVE),
  token: import_zod2.z.string()
}).catchall(import_zod2.z.unknown());
var BearerTokenConnectionDataSchema = import_zod2.z.discriminatedUnion("status", [
  BearerTokenInitiatingSchema,
  BearerTokenInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.INACTIVE)
  }).catchall(import_zod2.z.unknown()),
  BearerTokenInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.FAILED),
    error: import_zod2.z.string().optional(),
    error_description: import_zod2.z.string().optional()
  }).catchall(import_zod2.z.unknown()),
  BearerTokenInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.EXPIRED),
    expired_at: import_zod2.z.string().optional()
  }).catchall(import_zod2.z.unknown())
]);
var CustomBearerTokenConnectionDataSchema = BearerTokenInitiatingSchema.omit({
  status: true
});
var GoogleServiceAccountInitiatingSchema = BaseSchemeRaw.extend({
  status: import_zod2.z.literal(ConnectionStatuses.ACTIVE),
  credentials_json: import_zod2.z.string()
}).catchall(import_zod2.z.unknown());
var GoogleServiceAccountConnectionDataSchema = import_zod2.z.discriminatedUnion("status", [
  GoogleServiceAccountInitiatingSchema,
  GoogleServiceAccountInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.INACTIVE)
  }).catchall(import_zod2.z.unknown()),
  GoogleServiceAccountInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.FAILED),
    error: import_zod2.z.string().optional(),
    error_description: import_zod2.z.string().optional()
  }).catchall(import_zod2.z.unknown()),
  GoogleServiceAccountInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.EXPIRED),
    expired_at: import_zod2.z.string().optional()
  }).catchall(import_zod2.z.unknown())
]);
var NoAuthInitiatingSchema = BaseSchemeRaw.extend({
  status: import_zod2.z.literal(ConnectionStatuses.ACTIVE)
}).catchall(import_zod2.z.unknown());
var NoAuthConnectionDataSchema = import_zod2.z.discriminatedUnion("status", [
  NoAuthInitiatingSchema,
  NoAuthInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.INACTIVE)
  }).catchall(import_zod2.z.unknown()),
  NoAuthInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.FAILED),
    error: import_zod2.z.string().optional(),
    error_description: import_zod2.z.string().optional()
  }).catchall(import_zod2.z.unknown()),
  NoAuthInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.EXPIRED),
    expired_at: import_zod2.z.string().optional()
  }).catchall(import_zod2.z.unknown())
]);
var CustomNoAuthConnectionDataSchema = NoAuthInitiatingSchema.omit({
  status: true
});
var CalcomAuthInitiatingSchema = BaseSchemeRaw.extend({
  status: import_zod2.z.literal(ConnectionStatuses.ACTIVE)
}).catchall(import_zod2.z.unknown());
var CalcomAuthConnectionDataSchema = import_zod2.z.discriminatedUnion("status", [
  CalcomAuthInitiatingSchema,
  CalcomAuthInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.INACTIVE)
  }).catchall(import_zod2.z.unknown()),
  CalcomAuthInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.FAILED),
    error: import_zod2.z.string().optional(),
    error_description: import_zod2.z.string().optional()
  }).catchall(import_zod2.z.unknown()),
  CalcomAuthInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.EXPIRED),
    expired_at: import_zod2.z.string().optional()
  }).catchall(import_zod2.z.unknown())
]);
var BasicWithJwtInitiatingSchema = BaseSchemeRaw.extend({
  status: import_zod2.z.literal(ConnectionStatuses.ACTIVE),
  username: import_zod2.z.string(),
  password: import_zod2.z.string()
}).catchall(import_zod2.z.unknown());
var BasicWithJwtConnectionDataSchema = import_zod2.z.discriminatedUnion("status", [
  BasicWithJwtInitiatingSchema,
  BasicWithJwtInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.INACTIVE)
  }).catchall(import_zod2.z.unknown()),
  BasicWithJwtInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.FAILED),
    error: import_zod2.z.string().optional(),
    error_description: import_zod2.z.string().optional()
  }).catchall(import_zod2.z.unknown()),
  BasicWithJwtInitiatingSchema.extend({
    status: import_zod2.z.literal(ConnectionStatuses.EXPIRED),
    expired_at: import_zod2.z.string().optional()
  }).catchall(import_zod2.z.unknown())
]);
var CustomBasicWithJwtConnectionDataSchema = BasicWithJwtInitiatingSchema.omit({
  status: true
});
var ConnectionDataSchema = import_zod2.z.discriminatedUnion("authScheme", [
  import_zod2.z.object({
    authScheme: import_zod2.z.literal(AuthSchemeTypes.OAUTH1),
    /**
     * the main connection data discriminated by auth scheme
     */
    val: Oauth1ConnectionDataSchema
  }),
  import_zod2.z.object({
    authScheme: import_zod2.z.literal(AuthSchemeTypes.OAUTH2),
    /**
     * the main connection data discriminated by auth scheme
     */
    val: Oauth2ConnectionDataSchema
  }),
  import_zod2.z.object({
    authScheme: import_zod2.z.literal(AuthSchemeTypes.COMPOSIO_LINK),
    /**
     * the main connection data discriminated by auth scheme
     */
    val: ComposioLinkConnectionDataSchema
  }),
  import_zod2.z.object({
    authScheme: import_zod2.z.literal(AuthSchemeTypes.API_KEY),
    /**
     * the main connection data discriminated by auth scheme
     */
    val: ApiKeyConnectionDataSchema
  }),
  import_zod2.z.object({
    authScheme: import_zod2.z.literal(AuthSchemeTypes.BASIC),
    /**
     * the main connection data discriminated by auth scheme
     */
    val: BasicConnectionDataSchema
  }),
  import_zod2.z.object({
    authScheme: import_zod2.z.literal(AuthSchemeTypes.BEARER_TOKEN),
    /**
     * the main connection data discriminated by auth scheme
     */
    val: BearerTokenConnectionDataSchema
  }),
  import_zod2.z.object({
    authScheme: import_zod2.z.literal(AuthSchemeTypes.GOOGLE_SERVICE_ACCOUNT),
    /**
     * the main connection data discriminated by auth scheme
     */
    val: GoogleServiceAccountConnectionDataSchema
  }),
  import_zod2.z.object({
    authScheme: import_zod2.z.literal(AuthSchemeTypes.NO_AUTH),
    /**
     * the main connection data discriminated by auth scheme
     */
    val: NoAuthConnectionDataSchema
  }),
  import_zod2.z.object({
    authScheme: import_zod2.z.literal(AuthSchemeTypes.CALCOM_AUTH),
    /**
     * the main connection data discriminated by auth scheme
     */
    val: CalcomAuthConnectionDataSchema
  }),
  // z.object({
  //   authScheme: z.literal(AuthSchemeTypes.SNOWFLAKE),
  //   /**
  //    * the main connection data discriminated by auth scheme
  //    */
  //   val: SnowflakeConnectionDataSchema,
  // }),
  import_zod2.z.object({
    authScheme: import_zod2.z.literal(AuthSchemeTypes.BILLCOM_AUTH),
    /**
     * the main connection data discriminated by auth scheme
     */
    val: BillcomAuthConnectionDataSchema
  }),
  import_zod2.z.object({
    authScheme: import_zod2.z.literal(AuthSchemeTypes.BASIC_WITH_JWT),
    /**
     * the main connection data discriminated by auth scheme
     */
    val: BasicWithJwtConnectionDataSchema
  })
]);
var CustomConnectionDataSchema = import_zod2.z.discriminatedUnion("authScheme", [
  import_zod2.z.object({
    authScheme: import_zod2.z.literal(AuthSchemeTypes.OAUTH2),
    toolkitSlug: import_zod2.z.string(),
    val: CustomOauth2ConnectionDataSchema
  }),
  import_zod2.z.object({
    authScheme: import_zod2.z.literal(AuthSchemeTypes.API_KEY),
    toolkitSlug: import_zod2.z.string(),
    val: CustomApiKeyConnectionDataSchema
  }),
  import_zod2.z.object({
    authScheme: import_zod2.z.literal(AuthSchemeTypes.BASIC_WITH_JWT),
    toolkitSlug: import_zod2.z.string(),
    val: CustomBasicWithJwtConnectionDataSchema
  }),
  import_zod2.z.object({
    authScheme: import_zod2.z.literal(AuthSchemeTypes.BASIC),
    toolkitSlug: import_zod2.z.string(),
    val: CustomBasicConnectionDataSchema
  }),
  import_zod2.z.object({
    authScheme: import_zod2.z.literal(AuthSchemeTypes.BEARER_TOKEN),
    toolkitSlug: import_zod2.z.string(),
    val: CustomBearerTokenConnectionDataSchema
  }),
  import_zod2.z.object({
    authScheme: import_zod2.z.literal(AuthSchemeTypes.OAUTH1),
    toolkitSlug: import_zod2.z.string(),
    val: CustomOauth1ConnectionDataSchema
  }),
  import_zod2.z.object({
    authScheme: import_zod2.z.literal(AuthSchemeTypes.NO_AUTH),
    toolkitSlug: import_zod2.z.string(),
    val: CustomNoAuthConnectionDataSchema
  })
]);

// src/types/tool.types.ts
var ToolkitSchema = import_zod3.z.object({
  slug: import_zod3.z.string().describe("The slug of the toolkit"),
  name: import_zod3.z.string().describe("The name of the toolkit"),
  logo: import_zod3.z.string().describe("The logo of the toolkit").optional()
});
var JSONSchemaType = import_zod3.z.enum([
  "string",
  "number",
  "integer",
  "boolean",
  "object",
  "array",
  "null"
]);
var JSONSchemaPropertySchema = import_zod3.z.object({
  type: import_zod3.z.union([JSONSchemaType, import_zod3.z.array(JSONSchemaType)]).optional(),
  description: import_zod3.z.string().optional(),
  anyOf: import_zod3.z.lazy(() => import_zod3.z.array(JSONSchemaPropertySchema)).optional(),
  oneOf: import_zod3.z.lazy(() => import_zod3.z.array(JSONSchemaPropertySchema)).optional(),
  allOf: import_zod3.z.lazy(() => import_zod3.z.array(JSONSchemaPropertySchema)).optional(),
  not: import_zod3.z.lazy(() => JSONSchemaPropertySchema).optional(),
  title: import_zod3.z.string().optional(),
  default: import_zod3.z.any().optional(),
  nullable: import_zod3.z.boolean().optional(),
  properties: import_zod3.z.lazy(() => import_zod3.z.record(import_zod3.z.string(), JSONSchemaPropertySchema)).optional(),
  required: import_zod3.z.array(import_zod3.z.string()).optional(),
  file_uploadable: import_zod3.z.boolean().optional(),
  file_downloadable: import_zod3.z.boolean().optional(),
  items: import_zod3.z.lazy(() => import_zod3.z.union([JSONSchemaPropertySchema, import_zod3.z.array(JSONSchemaPropertySchema)])).optional(),
  enum: import_zod3.z.array(import_zod3.z.any()).optional(),
  const: import_zod3.z.any().optional(),
  minimum: import_zod3.z.number().optional(),
  maximum: import_zod3.z.number().optional(),
  exclusiveMinimum: import_zod3.z.number().optional(),
  exclusiveMaximum: import_zod3.z.number().optional(),
  multipleOf: import_zod3.z.number().optional(),
  minLength: import_zod3.z.number().optional(),
  maxLength: import_zod3.z.number().optional(),
  pattern: import_zod3.z.string().optional(),
  format: import_zod3.z.string().optional(),
  minItems: import_zod3.z.number().optional(),
  maxItems: import_zod3.z.number().optional(),
  uniqueItems: import_zod3.z.boolean().optional(),
  minProperties: import_zod3.z.number().optional(),
  maxProperties: import_zod3.z.number().optional(),
  patternProperties: import_zod3.z.lazy(() => import_zod3.z.record(import_zod3.z.string(), JSONSchemaPropertySchema)).optional(),
  additionalProperties: import_zod3.z.union([import_zod3.z.boolean(), import_zod3.z.lazy(() => JSONSchemaPropertySchema)]).optional(),
  examples: import_zod3.z.array(import_zod3.z.any()).optional(),
  readOnly: import_zod3.z.boolean().optional(),
  writeOnly: import_zod3.z.boolean().optional(),
  if: import_zod3.z.lazy(() => JSONSchemaPropertySchema).optional(),
  then: import_zod3.z.lazy(() => JSONSchemaPropertySchema).optional(),
  else: import_zod3.z.lazy(() => JSONSchemaPropertySchema).optional(),
  $ref: import_zod3.z.string().optional(),
  definitions: import_zod3.z.record(
    import_zod3.z.string(),
    import_zod3.z.lazy(() => JSONSchemaPropertySchema)
  ).optional(),
  $defs: import_zod3.z.record(
    import_zod3.z.string(),
    import_zod3.z.lazy(() => JSONSchemaPropertySchema)
  ).optional()
});
var ParametersSchema = import_zod3.z.object({
  type: import_zod3.z.literal("object"),
  anyOf: import_zod3.z.array(JSONSchemaPropertySchema).optional(),
  oneOf: import_zod3.z.array(JSONSchemaPropertySchema).optional(),
  allOf: import_zod3.z.array(JSONSchemaPropertySchema).optional(),
  not: JSONSchemaPropertySchema.optional(),
  properties: import_zod3.z.record(import_zod3.z.string(), JSONSchemaPropertySchema),
  required: import_zod3.z.array(import_zod3.z.string()).optional(),
  title: import_zod3.z.string().optional(),
  default: import_zod3.z.any().optional(),
  nullable: import_zod3.z.boolean().optional(),
  description: import_zod3.z.string().optional(),
  additionalProperties: import_zod3.z.boolean().default(false).optional()
});
var ToolSchema = import_zod3.z.object({
  slug: import_zod3.z.string().describe('The slug of the tool. eg. "GOOGLE_SEARCH"'),
  name: import_zod3.z.string().describe(`The name of the tool. eg. "Google Search"`),
  description: import_zod3.z.string().optional().describe("The description of the tool"),
  inputParameters: ParametersSchema.optional().describe("The input parameters of the tool"),
  outputParameters: ParametersSchema.optional().describe("The output parameters of the tool"),
  tags: import_zod3.z.optional(import_zod3.z.array(import_zod3.z.string())).describe("The tags of the tool. eg: Important").default([]),
  toolkit: import_zod3.z.optional(ToolkitSchema).describe("The toolkit of the tool"),
  version: import_zod3.z.optional(import_zod3.z.string()).describe('The version of the tool, e.g. "1.0.0"'),
  scopes: import_zod3.z.optional(import_zod3.z.array(import_zod3.z.string())).describe('The scopes of the tool. eg: ["task:add"]')
});
var ToolListResponseSchema = import_zod3.z.object({
  items: import_zod3.z.array(ToolSchema),
  nextCursor: import_zod3.z.string().nullable().optional(),
  totalPages: import_zod3.z.number()
});
var ToolListParamsSchema = import_zod3.z.object({
  tools: import_zod3.z.array(import_zod3.z.string()).optional(),
  toolkits: import_zod3.z.array(import_zod3.z.string()).optional(),
  scopes: import_zod3.z.array(import_zod3.z.string()).optional(),
  tags: import_zod3.z.array(import_zod3.z.string()).optional(),
  limit: import_zod3.z.number().optional(),
  search: import_zod3.z.string().optional(),
  authConfigIds: import_zod3.z.array(import_zod3.z.string()).optional()
});
var CustomAuthParamsSchema = import_zod3.z.object({
  baseURL: import_zod3.z.string().optional(),
  body: import_zod3.z.record(import_zod3.z.string(), import_zod3.z.unknown()).optional(),
  parameters: import_zod3.z.array(
    import_zod3.z.object({
      in: import_zod3.z.enum(["query", "header"]),
      name: import_zod3.z.string(),
      value: import_zod3.z.union([import_zod3.z.string(), import_zod3.z.number()])
    })
  )
});
var ToolExecuteParamsSchema = import_zod3.z.object({
  allowTracing: import_zod3.z.boolean().optional(),
  connectedAccountId: import_zod3.z.string().optional(),
  customAuthParams: CustomAuthParamsSchema.optional(),
  customConnectionData: CustomConnectionDataSchema.optional(),
  arguments: import_zod3.z.record(import_zod3.z.string(), import_zod3.z.unknown()).optional(),
  userId: import_zod3.z.string().optional(),
  //
  version: import_zod3.z.string().optional(),
  text: import_zod3.z.string().optional()
});
var ToolExecuteResponseSchema = import_zod3.z.object({
  data: import_zod3.z.record(import_zod3.z.string(), import_zod3.z.unknown()),
  error: import_zod3.z.string().nullable(),
  successful: import_zod3.z.boolean(),
  logId: import_zod3.z.string().optional(),
  sessionInfo: import_zod3.z.unknown().optional()
});
var ToolProxyParamsSchema = import_zod3.z.object({
  endpoint: import_zod3.z.string(),
  method: import_zod3.z.enum(["GET", "POST", "PUT", "DELETE", "PATCH"]),
  body: import_zod3.z.unknown().optional(),
  parameters: import_zod3.z.array(
    import_zod3.z.object({
      in: import_zod3.z.enum(["query", "header"]),
      name: import_zod3.z.string(),
      value: import_zod3.z.union([import_zod3.z.string(), import_zod3.z.number()])
    })
  ).optional(),
  connectedAccountId: import_zod3.z.string().optional(),
  customConnectionData: CustomConnectionDataSchema.optional()
});

// src/models/CustomTools.ts
var import_zod_to_json_schema = __toESM(require("zod-to-json-schema"), 1);

// src/utils/logger.ts
var import_chalk = __toESM(require("chalk"), 1);

// src/utils/constants.ts
var constants_exports = {};
__export(constants_exports, {
  CLIENT_PUSHER_KEY: () => CLIENT_PUSHER_KEY,
  COMPOSIO_DIR: () => COMPOSIO_DIR,
  COMPOSIO_LOG_LEVEL: () => COMPOSIO_LOG_LEVEL,
  DEFAULT_BASE_URL: () => DEFAULT_BASE_URL,
  DEFAULT_WEB_URL: () => DEFAULT_WEB_URL,
  IS_DEVELOPMENT_OR_CI: () => IS_DEVELOPMENT_OR_CI,
  TELEMETRY_URL: () => TELEMETRY_URL,
  TEMP_FILES_DIRECTORY_NAME: () => TEMP_FILES_DIRECTORY_NAME,
  USER_DATA_FILE_NAME: () => USER_DATA_FILE_NAME
});

// src/utils/env.ts
var getEnvVariable = (name, defaultValue = void 0) => {
  try {
    return process.env[name] || defaultValue;
  } catch (_e) {
    return defaultValue;
  }
};

// src/utils/constants.ts
var COMPOSIO_DIR = ".composio";
var USER_DATA_FILE_NAME = "user_data.json";
var TEMP_FILES_DIRECTORY_NAME = "files";
var DEFAULT_BASE_URL = "https://backend.composio.dev";
var DEFAULT_WEB_URL = "https://platform.composio.dev";
var TELEMETRY_URL = "https://app.composio.dev";
var CLIENT_PUSHER_KEY = getEnvVariable("CLIENT_PUSHER_KEY") || "ff9f18c208855d77a152";
var COMPOSIO_LOG_LEVEL = getEnvVariable("COMPOSIO_LOG_LEVEL");
var IS_DEVELOPMENT_OR_CI = getEnvVariable("DEVELOPMENT") || getEnvVariable("CI") || false;

// src/utils/logger.ts
var LOG_LEVELS = {
  silent: -1,
  // No logs
  error: 0,
  // Highest priority - critical errors
  warn: 1,
  // Warning messages
  info: 2,
  // General information
  debug: 3
  // Debug information
};
var getLogLevel = () => {
  const envLevel = (COMPOSIO_LOG_LEVEL ?? "info")?.toLowerCase();
  return envLevel && envLevel in LOG_LEVELS ? envLevel : "info";
};
var Logger = class {
  level;
  includeTimestamp;
  console;
  constructor(options = {}) {
    this.level = options.level ?? getLogLevel();
    this.includeTimestamp = options.includeTimestamp ?? true;
    this.console = console;
  }
  formatMessage(args) {
    const formattedArgs = args.map((arg, index) => {
      if (typeof arg === "object") {
        return JSON.stringify(arg);
      } else {
        if (index === 0) {
          if (args.length > 1) {
            return import_chalk.default.yellow(`${arg}`);
          } else {
            return String(arg);
          }
        }
        return String(arg);
      }
    }).join("\n");
    if (!this.includeTimestamp) {
      return formattedArgs;
    }
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    return `${import_chalk.default.gray(timestamp)} - ${formattedArgs}`;
  }
  shouldLog(level) {
    return LOG_LEVELS[level] <= LOG_LEVELS[this.level];
  }
  error(...args) {
    if (this.shouldLog("error")) {
      this.console.error(this.formatMessage(args));
    }
  }
  warn(...args) {
    if (this.shouldLog("warn")) {
      this.console.warn(this.formatMessage(args));
    }
  }
  info(...args) {
    if (this.shouldLog("info")) {
      this.console.info(this.formatMessage(args));
    }
  }
  debug(...args) {
    if (this.shouldLog("debug")) {
      this.console.debug(this.formatMessage(args));
    }
  }
};
var logger = new Logger();
var logger_default = logger;

// src/errors/ComposioError.ts
var import_chalk2 = __toESM(require("chalk"), 1);
var import_zod4 = require("zod");
var import_client = require("@composio/client");
var ComposioError = class _ComposioError extends Error {
  /** @readonly Error name */
  name = "ComposioError";
  code;
  possibleFixes;
  errorId;
  /**
   * Creates a new ComposioError
   * @param message Error message
   * @param options Additional error options
   */
  constructor(message, options = {}) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    const statusCode = options.statusCode || (options.cause instanceof import_client.BadRequestError ? options.cause.status : void 0);
    this.code = `TS-SDK::${options.code}`;
    this.possibleFixes = options.possibleFixes;
    this.definePropertyIfExists("statusCode", statusCode);
    this.definePropertyIfExists("cause", options.cause);
    const combinedStack = options.cause instanceof Error ? _ComposioError.combineStackTraces(options.cause.stack, this.stack) : options.stack ?? this.stack;
    this.definePropertyIfExists("stack", combinedStack);
    if (options.meta && Object.keys(options.meta).length > 0) {
      this.definePropertyIfExists("meta", options.meta);
    }
  }
  /**
   * Helper method to define a property only if it has a value
   * @param propertyName Name of the property to define
   * @param value Value to assign to the property
   * @private
   */
  definePropertyIfExists(propertyName, value) {
    if (value !== void 0) {
      Object.defineProperty(this, propertyName, {
        value,
        enumerable: true,
        writable: false,
        configurable: true
      });
    }
  }
  /**
   * Helper method to combine stack traces when wrapping errors
   * This ensures the full call chain is preserved
   * @param originalStack The stack of the error being wrapped
   * @param currentStack The stack of the wrapper error
   * @returns Combined stack trace
   * @private
   */
  static combineStackTraces(originalStack, currentStack) {
    if (!originalStack) return currentStack;
    if (!currentStack) return originalStack;
    const currentHeader = currentStack.split("\n")[0];
    const originalStackBody = originalStack.split("\n").slice(1).join("\n");
    return `${currentHeader}
${currentStack.split("\n").slice(1).join("\n")}

Caused by:
${originalStackBody}`;
  }
  /**
   * Extract and normalize error data for formatting
   * @param includeStack Whether to include stack trace information
   * @returns Structured error data for formatting
   * @private
   */
  getErrorData(includeStack = false) {
    const data = {
      name: this.name,
      message: this.message
    };
    const { cause, code, stack, statusCode, meta, possibleFixes } = this;
    if (cause !== void 0) {
      const rawCause = cause;
      data.cause = rawCause instanceof Error ? rawCause.message : String(rawCause);
    }
    if (code) {
      data.code = code;
    }
    if (statusCode !== void 0) {
      data.statusCode = statusCode;
    }
    if (meta) {
      data.meta = meta;
    }
    if (possibleFixes) {
      data.possibleFixes = possibleFixes;
    }
    if (includeStack && stack) {
      if (stack.includes("Caused by:")) {
        const [currentStack, causeStack] = stack.split("Caused by:");
        data.stack = [
          ...currentStack.split("\n").slice(1),
          "Caused by:",
          ...causeStack.split("\n")
        ];
      } else {
        data.stack = stack.split("\n").slice(1);
      }
    }
    return data;
  }
  /**
   * Prints a user-friendly, colorful representation of the error to the logger
   * @param includeStack Whether to include the stack trace in the output (default: false)
   */
  prettyPrint(includeStack = false) {
    const data = this.getErrorData(includeStack);
    let output = "\n" + import_chalk2.default.bgRed.white.bold(" ERROR ") + " " + import_chalk2.default.white.bold(data.message) + "\n";
    if (data.code) {
      output += import_chalk2.default.yellow(`Error Code: ${data.code}`) + "\n";
    }
    if (data.statusCode !== void 0) {
      output += import_chalk2.default.yellow(`Status: ${data.statusCode}`) + "\n";
    }
    if (data.cause) {
      output += import_chalk2.default.gray("Reason:") + "\n";
      output += "  " + import_chalk2.default.white(data.cause) + "\n";
    }
    if (data.meta) {
      output += import_chalk2.default.gray("Additional Information:") + "\n";
      output += "  " + import_chalk2.default.white(JSON.stringify(data.meta, null, 2).replace(/\n/g, "\n  ")) + "\n";
    }
    if (data.possibleFixes?.length) {
      output += "\n" + import_chalk2.default.cyan.bold("Try the following:") + "\n";
      const fixes = data.possibleFixes?.map((fix, index) => ` ${index + 1}. ` + import_chalk2.default.white(fix));
      output += fixes?.join("\n") + "\n";
    }
    if (data.stack?.length) {
      output += "\n" + import_chalk2.default.gray("Stack Trace:") + "\n";
      output += import_chalk2.default.gray(data.stack.join("\n")) + "\n";
    }
    output += "\n";
    logger_default.error(output);
  }
  /**
   * Static factory method to create and pretty print an error in one step
   * @param message Error message
   * @param options Error options
   * @param includeStack Whether to include the stack trace in the output
   * @returns The created error instance
   */
  static createAndPrint(message, options = {}, includeStack = false) {
    const error = new _ComposioError(message, options);
    error.prettyPrint(includeStack);
    return error;
  }
  /**
   * Utility function to handle errors in a consistent way
   * This properly displays the error and exits the process if needed
   * @param error The error to handle
   * @param options Options for error handling
   */
  static handle(error, options = {}) {
    const { includeStack = false, exitProcess = false, exitCode = 1 } = options;
    if (error instanceof _ComposioError) {
      error.prettyPrint(includeStack);
    } else if (error instanceof import_zod4.ZodError) {
      this.handleZodError(error, includeStack);
    } else if (error instanceof Error) {
      this.handleStandardError(error, includeStack);
    } else {
      this.handleUnknownError(error);
    }
    if (exitProcess && typeof process !== "undefined") {
      process.exit(exitCode);
    }
  }
  /**
   * Helper method to handle Zod validation errors
   * @param error The Zod error to handle
   * @param includeStack Whether to include the stack trace
   * @private
   */
  static handleZodError(error, includeStack) {
    logger_default.error("\n" + import_chalk2.default.bgRed.white.bold(" ERROR ") + " " + import_chalk2.default.white.bold(error.message));
    logger_default.error(import_chalk2.default.gray("Invalid parameters:"));
    error.errors.forEach((err) => {
      logger_default.error(import_chalk2.default.yellow(err.path.join(".")) + " " + import_chalk2.default.white(err.message));
    });
    logger_default.error(import_chalk2.default.gray("Expected parameters:"));
    error.errors.forEach((err) => {
      logger_default.error(import_chalk2.default.yellow(err.path.join(".")) + " " + import_chalk2.default.white(err.message));
    });
    if (includeStack) {
      logger_default.error("\n" + import_chalk2.default.gray("Validation Errors:"));
      error.errors.forEach((err) => {
        const path = err.path.join(".");
        logger_default.error(
          import_chalk2.default.gray("  \u2022 ") + import_chalk2.default.yellow(path ? `${path}: ` : "") + import_chalk2.default.white(err.message)
        );
      });
      if (error.stack) {
        logger_default.error("\n" + import_chalk2.default.gray("Stack Trace:"));
        const stackLines = error.stack.split("\n").slice(1);
        logger_default.error(import_chalk2.default.gray(stackLines.join("\n")));
      }
    }
    logger_default.error("");
  }
  /**
   * Helper method to handle standard Error objects
   * @param error The standard error to handle
   * @param includeStack Whether to include the stack trace
   * @private
   */
  static handleStandardError(error, includeStack) {
    logger_default.error("\n" + import_chalk2.default.bgRed.white.bold(" ERROR ") + " " + import_chalk2.default.white.bold(error.message));
    if (includeStack && error.stack) {
      logger_default.error("\n" + import_chalk2.default.gray("Stack Trace:"));
      const stackLines = error.stack.split("\n").slice(1);
      logger_default.error(import_chalk2.default.gray(stackLines.join("\n")));
    }
    logger_default.error("");
  }
  /**
   * Helper method to handle unknown error types
   * @param error The unknown error value
   * @private
   */
  static handleUnknownError(error) {
    logger_default.error(
      "\n" + import_chalk2.default.bgRed.white.bold(" ERROR ") + " " + import_chalk2.default.white.bold("Unknown error occurred")
    );
    if (error !== null && error !== void 0) {
      logger_default.error(import_chalk2.default.gray("Error details:"));
      logger_default.error("  " + import_chalk2.default.white(String(error)));
    }
    logger_default.error("");
  }
};

// src/errors/ToolErrors.ts
var ToolErrorCodes = {
  TOOLSET_NOT_DEFINED: "TOOLSET_NOT_DEFINED",
  TOOL_NOT_FOUND: "TOOL_NOT_FOUND",
  INVALID_MODIFIER: "INVALID_MODIFIER",
  CUSTOM_TOOLS_NOT_INITIALIZED: "CUSTOM_TOOLS_NOT_INITIALIZED",
  TOOL_EXECUTION_ERROR: "TOOL_EXECUTION_ERROR",
  INVALID_EXECUTE_FUNCTION: "INVALID_EXECUTE_FUNCTION",
  GLOBAL_EXECUTE_TOOL_FN_NOT_SET: "GLOBAL_EXECUTE_TOOL_FN_NOT_SET"
};
var ComposioProviderNotDefinedError = class extends ComposioError {
  constructor(message = "Provider not defined", options = {}) {
    super(message, {
      ...options,
      code: ToolErrorCodes.TOOLSET_NOT_DEFINED,
      possibleFixes: options.possibleFixes || [
        "Ensure that the provider is defined in the Composio project and passed into the tool instance"
      ]
    });
    this.name = "ComposioProviderNotDefinedError";
  }
};
var ComposioToolNotFoundError = class extends ComposioError {
  constructor(message = "Tool not found", options = {}) {
    super(message, {
      ...options,
      code: ToolErrorCodes.TOOL_NOT_FOUND,
      possibleFixes: options.possibleFixes || [
        "Ensure the tool slug is correct and exists in the Composio project"
      ]
    });
    this.name = "ComposioToolNotFoundError";
  }
};
var ComposioInvalidModifierError = class extends ComposioError {
  constructor(message = "Invalid modifier", options = {}) {
    super(message, {
      ...options,
      code: ToolErrorCodes.INVALID_MODIFIER,
      possibleFixes: options.possibleFixes || [
        "Ensure the modifier is a function and returns a valid result"
      ]
    });
    this.name = "ComposioInvalidModifierError";
  }
};
var ComposioCustomToolsNotInitializedError = class extends ComposioError {
  constructor(message = "Custom tools not initialized", options = {}) {
    super(message, {
      ...options,
      code: ToolErrorCodes.CUSTOM_TOOLS_NOT_INITIALIZED,
      possibleFixes: options.possibleFixes || [
        "Ensure the custom tools class is initialized in the Tools instance"
      ]
    });
    this.name = "ComposioCustomToolsNotInitializedError";
  }
};
var ComposioToolExecutionError = class extends ComposioError {
  error;
  constructor(message = "Tool execution error", options = {}) {
    const { originalError, ...restOptions } = options;
    super(message, {
      ...restOptions,
      code: options.code || ToolErrorCodes.TOOL_EXECUTION_ERROR,
      cause: options.cause || originalError,
      possibleFixes: options.possibleFixes || [
        "Ensure the tool is correctly configured and the input is valid"
      ]
    });
    this.error = originalError || (options.cause instanceof Error ? options.cause : options.cause ? new Error(String(options.cause)) : new Error("Unknown error"));
    this.name = "ComposioToolExecutionError";
  }
};
var ComposioInvalidExecuteFunctionError = class extends ComposioError {
  constructor(message = "Invalid execute function", options = {}) {
    super(message, {
      ...options,
      code: ToolErrorCodes.INVALID_EXECUTE_FUNCTION,
      possibleFixes: options.possibleFixes || [
        "Ensure the execute function is a valid function and returns a valid result"
      ]
    });
    this.name = "ComposioInvalidExecuteFunctionError";
  }
};
var ComposioGlobalExecuteToolFnNotSetError = class extends ComposioError {
  constructor(message = "Global execute tool function not set", options = {}) {
    super(message, {
      ...options,
      code: ToolErrorCodes.GLOBAL_EXECUTE_TOOL_FN_NOT_SET,
      possibleFixes: options.possibleFixes || [
        "Ensure the global execute tool function is set in the provider"
      ]
    });
    this.name = "ComposioGlobalExecuteToolFnNotSetError";
  }
};

// src/errors/ConnectedAccountsErrors.ts
var ConnectedAccountErrorCodes = {
  CONNECTED_ACCOUNT_NOT_FOUND: "CONNECTED_ACCOUNT_NOT_FOUND",
  MULTIPLE_CONNECTED_ACCOUNTS: "MULTIPLE_CONNECTED_ACCOUNTS"
};
var ComposioConnectedAccountNotFoundError = class extends ComposioError {
  constructor(message = "Connected account not found", options = {}) {
    super(message, {
      ...options,
      code: ConnectedAccountErrorCodes.CONNECTED_ACCOUNT_NOT_FOUND,
      statusCode: 404,
      possibleFixes: options.possibleFixes || [
        "Ensure the connected account exists and is active in your Composio dashboard"
      ]
    });
    this.name = "ComposioConnectedAccountNotFoundError";
  }
};
var ComposioMultipleConnectedAccountsError = class extends ComposioError {
  constructor(message = "Multiple connected accounts found") {
    super(message, {
      code: ConnectedAccountErrorCodes.MULTIPLE_CONNECTED_ACCOUNTS,
      possibleFixes: [
        "Use the allowMultiple flag to allow multiple connected accounts per user for an auth config"
      ]
    });
    this.name = "ComposioMultipleConnectedAccountsError";
  }
};

// src/telemetry/Telemetry.ts
var import_client2 = require("@composio/client");

// src/types/telemetry.types.ts
var TELEMETRY_EVENTS = {
  SDK_INITIALIZED: "SDK_INITIALIZED",
  SDK_METHOD_INVOKED: "SDK_METHOD_INVOKED",
  SDK_METHOD_ERROR: "SDK_METHOD_ERROR",
  CLI_INVOKED: "CLI_INVOKED"
};

// src/telemetry/BatchProcessor.ts
var BatchProcessor = class {
  batch = [];
  time;
  batchSize;
  processBatchCallback;
  timer = null;
  constructor(time = 2e3, batchSize = 100, processBatchCallback) {
    this.batch = [];
    this.time = time;
    this.batchSize = batchSize;
    this.processBatchCallback = processBatchCallback;
  }
  pushItem(item) {
    this.batch.push(item);
    if (this.batch.length >= this.batchSize) {
      this.processBatch();
    } else if (!this.timer) {
      this.timer = setTimeout(() => this.processBatch(), this.time);
    }
  }
  processBatch() {
    if (this.batch.length > 0) {
      this.processBatchCallback(this.batch);
      this.batch = [];
    }
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
  }
};

// src/utils/uuid.ts
var import_uuid = require("uuid");
function getRandomUUID() {
  return (0, import_uuid.v4)();
}
function getRandomShortId() {
  return getRandomUUID().slice(0, 8).replace(/-/g, "");
}

// src/services/telemetry/TelemetryService.ts
var TELEMETRY_URL2 = "https://telemetry.composio.dev/v1";
var TelemetryService = class {
  /**
   * Sends a metric to the Telemetry API.
   * @param payload - The payload to send to the Telemetry API.
   * @returns The response from the Telemetry API.
   */
  static async sendMetric(payload) {
    try {
      const result = await fetch(`${TELEMETRY_URL2}/metrics/invocations`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(payload)
      });
      return result;
    } catch (error) {
      logger_default.debug("Error sending metric telemetry", error);
    }
  }
  /**
   * Sends an error log to the Telemetry API.
   * @param payload - The payload to send to the Telemetry API.
   * @returns The response from the Telemetry API.
   */
  static async sendErrorLog(payload) {
    try {
      const result = await fetch(`${TELEMETRY_URL2}/errors`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(payload)
      });
      return result;
    } catch (error) {
      logger_default.debug("Error sending error telemetry", error);
    }
  }
};

// src/telemetry/Telemetry.ts
var TelemetryTransport = class {
  telemetryMetadata;
  isTelemetryDisabled = true;
  telemetrySource;
  telemetrySourceName = "typescript-sdk";
  telemetryServiceName = "sdk";
  telemetryLanguage = "typescript";
  batchProcessor = new BatchProcessor(200, 10, async (data) => {
    logger_default.debug("Sending batch of telemetry metrics", data);
    await TelemetryService.sendMetric(data);
  });
  setup(metadata) {
    this.telemetryMetadata = metadata;
    this.isTelemetryDisabled = false;
    this.telemetrySource = {
      host: this.telemetryMetadata?.host ?? this.telemetrySourceName,
      service: this.telemetryServiceName,
      language: this.telemetryLanguage,
      version: this.telemetryMetadata?.version,
      platform: this.telemetryMetadata?.isBrowser ? "browser" : "node",
      environment: getEnvVariable("NODE_ENV", "production")
    };
    this.sendMetric([
      {
        functionName: TELEMETRY_EVENTS.SDK_INITIALIZED,
        durationMs: 0,
        timestamp: Date.now() / 1e3,
        props: {},
        source: this.telemetrySource,
        metadata: {
          provider: this.telemetryMetadata?.provider ?? "openai"
        },
        error: void 0
      }
    ]);
  }
  /**
   * Instrument the telemetry for the given instance.
   *
   * You can pass the instance and the file name of the instance to instrument the telemetry.
   * This will instrument all the methods of the instance and log the telemetry for each method call.
   * @param instance - any instance that extends InstrumentedInstance
   * @param fileName - the file name of the instance
   * @returns
   */
  instrument(instance, fileName) {
    const proto = Object.getPrototypeOf(instance);
    const methodNames = Object.getOwnPropertyNames(proto).filter((key) => {
      const descriptor = Object.getOwnPropertyDescriptor(proto, key);
      return key !== "constructor" && descriptor && typeof descriptor.value === "function" && descriptor.value.constructor.name === "AsyncFunction";
    });
    const instrumentedClassName = (instance.constructor?.name || fileName) ?? "unknown";
    for (const name of methodNames) {
      const originalMethod = instance[name];
      instance[name] = async (...args) => {
        if (this.shouldSendTelemetry()) {
          const telemetryPayload = {
            functionName: `${instrumentedClassName}.${name}`,
            durationMs: 0,
            timestamp: Date.now() / 1e3,
            props: {
              fileName: instrumentedClassName,
              method: name,
              params: args
            },
            metadata: {
              provider: this.telemetryMetadata?.provider ?? "openai"
            },
            error: void 0,
            source: this.telemetrySource
          };
          this.batchProcessor.pushItem(telemetryPayload);
        }
        try {
          return await originalMethod.apply(instance, args);
        } catch (error) {
          if (error instanceof Error) {
            if (!error.errorId) {
              error.errorId = getRandomUUID();
              if (this.shouldSendTelemetry()) {
                await this.prepareAndSendErrorTelemetry(error, instrumentedClassName, name, args);
              }
            }
          }
          throw error;
        }
      };
    }
    return instance;
  }
  /**
   * Check if the telemetry should be sent.
   * @returns true if the telemetry should be sent, false otherwise
   */
  shouldSendTelemetry() {
    const telemetryDisabledEnvironments = ["test", "ci"];
    const nodeEnv = (getEnvVariable("NODE_ENV", "development") || "").toLowerCase();
    const isDisabledEnvironment = telemetryDisabledEnvironments.includes(nodeEnv);
    const isTelemetryDisabledByEnv = getEnvVariable("TELEMETRY_DISABLED", "false") === "true";
    return !this.isTelemetryDisabled && !isTelemetryDisabledByEnv && !isDisabledEnvironment;
  }
  /**
   * Prepare and send the error telemetry.
   *
   * @TODO This currently blocks the thread and sends the telemetry to the server.
   *
   * @param {unknown} error - The error to send.
   * @param {string} instrumentedClassName - The class name of the instrumented class.
   * @param {string} name - The name of the method that threw the error.
   */
  async prepareAndSendErrorTelemetry(error, instrumentedClassName, name, args) {
    const telemetryPayload = {
      functionName: `${instrumentedClassName}.${name}`,
      durationMs: 0,
      timestamp: Date.now() / 1e3,
      props: {
        fileName: instrumentedClassName,
        method: name,
        params: args
      },
      metadata: {
        provider: this.telemetryMetadata?.provider ?? "openai"
      },
      source: this.telemetrySource
    };
    if (error instanceof import_client2.ComposioError) {
      telemetryPayload.error = {
        errorId: error.errorId,
        name: error.name,
        message: error.message,
        stack: error.stack
      };
    } else if (error instanceof ComposioError) {
      telemetryPayload.error = {
        errorId: error.errorId,
        name: error.name,
        code: error.code,
        message: error.message,
        stack: error.stack
      };
    } else if (error instanceof Error) {
      telemetryPayload.error = {
        errorId: error.errorId,
        name: error.name ?? "Unknown error",
        message: error.message,
        stack: error.stack
      };
    }
    await this.sendErrorTelemetry(telemetryPayload);
  }
  /**
   * Send the telemetry payload to the server.
   * @param payload - the telemetry payload to send
   * @returns
   */
  async sendMetric(payload) {
    if (!this.shouldSendTelemetry()) {
      logger_default.debug("Telemetry is disabled, skipping metric telemetry", payload);
      return;
    }
    try {
      logger_default.debug("SDK Metric", payload);
      await TelemetryService.sendMetric(payload);
    } catch (error) {
      logger_default.error("Error sending metric telemetry", error);
    }
  }
  // @TODO: check if this will send the error telemetry to the server
  async sendErrorTelemetry(payload) {
    if (!this.shouldSendTelemetry()) {
      logger_default.debug("Telemetry is disabled, skipping metric telemetry", payload);
      return;
    }
    try {
      logger_default.debug("SDK Error Telemetry", payload);
      await TelemetryService.sendErrorLog(payload);
    } catch (error) {
      logger_default.error("Error sending error telemetry", error);
    }
  }
};
var telemetry = new TelemetryTransport();

// src/errors/AuthConfigErrors.ts
var AuthConfigErrorCodes = {
  AUTH_CONFIG_NOT_FOUND: "AUTH_CONFIG_NOT_FOUND"
};
var ComposioAuthConfigNotFoundError = class extends ComposioError {
  constructor(message = "Auth config not found", options = {}) {
    super(message, {
      ...options,
      code: AuthConfigErrorCodes.AUTH_CONFIG_NOT_FOUND,
      possibleFixes: options.possibleFixes || [
        "Check if the auth config exists",
        "Check if the auth config id is correct",
        "Check if the auth config is enabled"
      ]
    });
    this.name = "ComposioAuthConfigNotFoundError";
  }
};

// src/errors/ConnectionRequestErrors.ts
var ConnectionRequestErrorCodes = {
  CONNECTION_REQUEST_TIMEOUT: "CONNECTION_REQUEST_TIMEOUT",
  CONNECTION_REQUEST_FAILED: "CONNECTION_REQUEST_FAILED"
};
var ConnectionRequestTimeoutError = class extends ComposioError {
  constructor(message = "Connection request timed out", options = {}) {
    super(message, {
      ...options,
      code: ConnectionRequestErrorCodes.CONNECTION_REQUEST_TIMEOUT
    });
    this.name = "ConnectionRequestTimeoutError";
  }
};
var ConnectionRequestFailedError = class extends ComposioError {
  constructor(message = "Connection request failed", options = {}) {
    super(message, {
      ...options,
      code: ConnectionRequestErrorCodes.CONNECTION_REQUEST_FAILED
    });
    this.name = "ConnectionRequestFailedError";
  }
};

// src/errors/ToolkitErrors.ts
var ToolkitErrorCodes = {
  TOOLKIT_NOT_FOUND: "TOOLKIT_NOT_FOUND"
};
var ComposioToolkitNotFoundError = class extends ComposioError {
  constructor(message = "Toolkit not found", options = {}) {
    super(message, {
      ...options,
      code: "TOOLKIT_NOT_FOUND",
      possibleFixes: options.possibleFixes || [
        "Ensure the toolkit is correctly configured and the slug is valid"
      ]
    });
    this.name = "ComposioToolkitNotFoundError";
  }
};
var ComposioToolkitFetchError = class extends ComposioError {
  constructor(message = "Failed to fetch toolkit", options = {}) {
    super(message, {
      ...options,
      code: "TOOLKIT_FETCH_ERROR",
      possibleFixes: options.possibleFixes || [
        "Ensure the toolkit slug is valid",
        "Ensure you are using the correct API key",
        "Ensure you are using the correct API endpoint / Base URL and it is working"
      ]
    });
    this.name = "ComposioToolkitFetchError";
  }
};

// src/errors/ValidationErrors.ts
var import_zod5 = require("zod");
var ValidationErrorCodes = {
  VALIDATION_ERROR: "VALIDATION_ERROR",
  JSON_SCHEMA_TO_ZOD_ERROR: "JSON_SCHEMA_TO_ZOD_ERROR"
};
var ValidationError = class extends ComposioError {
  constructor(message = "Input validation failed", options = {}) {
    const { cause: providedZodError, ...restOptions } = options;
    let zodErrorInstance;
    if (providedZodError instanceof import_zod5.ZodError) {
      zodErrorInstance = providedZodError;
    } else {
      zodErrorInstance = new import_zod5.ZodError([
        {
          path: [],
          message: "Invalid input",
          code: "custom"
        }
      ]);
    }
    const issues = zodErrorInstance.issues.map(
      (issue) => `[${issue.code}] ${issue.path.join(".")} - ${issue.message}`
    );
    super(message, {
      ...restOptions,
      code: options.code || ValidationErrorCodes.VALIDATION_ERROR,
      possibleFixes: issues,
      cause: zodErrorInstance
    });
    this.name = "ValidationError";
    const userFriendlyMessage = this.generateUserFriendlyMessage();
    this.message = `${message}: ${userFriendlyMessage}`;
  }
  generateUserFriendlyMessage() {
    if (this.cause instanceof import_zod5.ZodError && this.cause.issues.length > 0) {
      const issue = this.cause.issues[0];
      const path = issue.path.join(".");
      const param = path || "parameter";
      if (issue.code === "invalid_type") {
        return `The ${param} should be a ${issue.expected}, but you provided a ${issue.received}`;
      }
      return issue.message;
    }
    return "Please check your input parameters";
  }
};
var JsonSchemaToZodError = class extends ComposioError {
  constructor(message = "Failed to convert JSON schema to Zod schema", options = {}) {
    super(message, {
      ...options,
      code: options.code || ValidationErrorCodes.JSON_SCHEMA_TO_ZOD_ERROR
    });
  }
};

// src/errors/SDKErrors.ts
var SDKErrorCodes = {
  NO_API_KEY_PROVIDED: "NO_API_KEY_PROVIDED"
};
var ComposioNoAPIKeyError = class extends ComposioError {
  constructor(message = "No Composio API key provided", options = {}) {
    const defaultCause = "Couldn't find an API key in the params, environment variables or in the user config file";
    super(message, {
      ...options,
      code: "NO_API_KEY",
      cause: options.cause || defaultCause,
      possibleFixes: options.possibleFixes || [
        "Ensure you have an API key passed in the params, or in environment variable (COMPOSIO_API_KEY) or in the user config file",
        "To get an API key, please sign up at https://composio.dev/signup",
        "You can also use the Composio CLI to create a project and get an API key"
      ],
      statusCode: 401
    });
    this.name = "ComposioNoAPIKeyError";
  }
};

// src/types/connectedAccounts.types.ts
var import_zod6 = require("zod");
var ConnectedAccountStatuses = {
  INITIALIZING: "INITIALIZING",
  INITIATED: "INITIATED",
  ACTIVE: "ACTIVE",
  FAILED: "FAILED",
  EXPIRED: "EXPIRED",
  INACTIVE: "INACTIVE"
};
var ConnectedAccountStatusSchema = import_zod6.z.enum([
  ConnectedAccountStatuses.INITIALIZING,
  ConnectedAccountStatuses.INITIATED,
  ConnectedAccountStatuses.ACTIVE,
  ConnectedAccountStatuses.FAILED,
  ConnectedAccountStatuses.EXPIRED,
  ConnectedAccountStatuses.INACTIVE
]);
var CreateConnectedAccountParamsSchema = import_zod6.z.object({
  authConfig: import_zod6.z.object({
    id: import_zod6.z.string()
  }),
  connection: import_zod6.z.object({
    data: import_zod6.z.record(import_zod6.z.string(), import_zod6.z.unknown()).optional(),
    callbackUrl: import_zod6.z.string().optional(),
    userId: import_zod6.z.string().optional()
  })
});
var DefaultCreateConnectedAccountParamsSchema = import_zod6.z.object({
  auth_config: import_zod6.z.object({
    id: import_zod6.z.string()
  }),
  connection: import_zod6.z.object({
    state: ConnectionDataSchema.optional(),
    data: import_zod6.z.record(import_zod6.z.string(), import_zod6.z.unknown()).optional(),
    callback_url: import_zod6.z.string().optional(),
    user_id: import_zod6.z.string().optional()
  })
});
var CreateConnectedAccountOptionsSchema = import_zod6.z.object({
  allowMultiple: import_zod6.z.boolean().optional(),
  callbackUrl: import_zod6.z.string().optional(),
  config: ConnectionDataSchema.optional()
});
var CreateConnectedAccountResponseSchema = import_zod6.z.object({
  id: import_zod6.z.string(),
  status: ConnectedAccountStatusSchema,
  redirectUrl: import_zod6.z.string().nullable()
});
var ConnectedAccountAuthConfigSchema = import_zod6.z.object({
  id: import_zod6.z.string(),
  isComposioManaged: import_zod6.z.boolean(),
  isDisabled: import_zod6.z.boolean()
});
var ConnectedAccountRetrieveResponseSchema = import_zod6.z.object({
  id: import_zod6.z.string(),
  authConfig: ConnectedAccountAuthConfigSchema,
  data: import_zod6.z.record(import_zod6.z.string(), import_zod6.z.unknown()).optional(),
  params: import_zod6.z.record(import_zod6.z.string(), import_zod6.z.unknown()).optional(),
  status: ConnectedAccountStatusSchema,
  statusReason: import_zod6.z.string().nullable(),
  toolkit: import_zod6.z.object({
    slug: import_zod6.z.string()
  }),
  state: ConnectionDataSchema.optional(),
  testRequestEndpoint: import_zod6.z.string().optional(),
  isDisabled: import_zod6.z.boolean(),
  createdAt: import_zod6.z.string(),
  updatedAt: import_zod6.z.string()
});
var ConnectedAccountListParamsSchema = import_zod6.z.object({
  authConfigIds: import_zod6.z.array(import_zod6.z.string()).nullable().optional().describe("The auth config ids of the connected accounts"),
  cursor: import_zod6.z.string().nullish().describe("The cursor to paginate through the connected accounts"),
  labels: import_zod6.z.array(import_zod6.z.string()).nullable().optional().describe("The labels of the connected accounts"),
  limit: import_zod6.z.number().nullable().optional().describe("The limit of the connected accounts to return"),
  orderBy: import_zod6.z.enum(["created_at", "updated_at"]).optional().describe("The order by of the connected accounts"),
  statuses: import_zod6.z.array(ConnectedAccountStatusSchema).nullable().optional().describe("The statuses of the connected accounts"),
  toolkitSlugs: import_zod6.z.array(import_zod6.z.string()).nullable().optional().describe("The toolkit slugs of the connected accounts"),
  userIds: import_zod6.z.array(import_zod6.z.string()).nullable().optional().describe("The user ids of the connected accounts")
});
var ConnectedAccountListResponseSchema = import_zod6.z.object({
  items: import_zod6.z.array(ConnectedAccountRetrieveResponseSchema).describe("The list of connected accounts"),
  nextCursor: import_zod6.z.string().nullish().describe("The next cursor to paginate through the connected accounts"),
  totalPages: import_zod6.z.number().describe("The total number of pages of connected accounts")
});

// src/utils/transform.ts
function transform(raw) {
  return {
    with(schema) {
      return {
        using(transformer, options) {
          const transformed = transformer(raw);
          const result = schema.safeParse(transformed);
          if (!result.success) {
            logger_default.error(result.error);
            return transformed;
          }
          return result.data;
        }
      };
    }
  };
}

// src/utils/transformers/connectedAccounts.ts
function transformConnectedAccountResponse(response) {
  return transform(response).with(ConnectedAccountRetrieveResponseSchema).using((response2) => ({
    ...response2,
    authConfig: {
      ...response2.auth_config,
      id: response2.auth_config.id,
      isComposioManaged: response2.auth_config.is_composio_managed,
      isDisabled: response2.auth_config.is_disabled
    },
    data: response2.data ?? void 0,
    state: response2.state,
    status: response2.status,
    statusReason: response2.status_reason,
    isDisabled: response2.is_disabled,
    createdAt: response2.created_at,
    updatedAt: response2.updated_at,
    testRequestEndpoint: response2.test_request_endpoint
  }));
}
function transformConnectedAccountListResponse(response) {
  return transform(response).with(ConnectedAccountListResponseSchema).using((response2) => ({
    items: response2.items.map(transformConnectedAccountResponse),
    nextCursor: response2.next_cursor ?? null,
    totalPages: response2.total_pages
  }));
}

// src/models/CustomTools.ts
var CustomTools = class {
  client;
  customToolsRegistry;
  constructor(client) {
    if (!client) {
      throw new ComposioError("ComposioClient is required");
    }
    this.client = client;
    this.customToolsRegistry = /* @__PURE__ */ new Map();
    telemetry.instrument(this);
  }
  /**
   * Create a custom tool and registers it in the registry.
   * This is just an in memory registry and is not persisted.
   * @param {CustomToolOptions} toolOptions CustomToolOptions
   * @returns {Tool} The tool created
   *
   * @example
   * ```typescript
   * // Create a custom tool with input parameters
   * const customTool = await composio.customTools.createTool({
   *   name: 'My Custom Tool',
   *   description: 'A tool that performs a custom operation',
   *   slug: 'MY_CUSTOM_TOOL',
   *   inputParams: z.object({
   *     query: z.string().describe('The search query'),
   *     limit: z.number().optional().describe('Maximum number of results')
   *   }),
   *   execute: async (input, connectionConfig, executeToolRequest) => {
   *     // Custom implementation logic
   *     return {
   *       data: { results: ['result1', 'result2'] }
   *     };
   *   }
   * });
   * ```
   */
  async createTool(toolOptions) {
    const { slug, execute, inputParams, name, description } = toolOptions;
    if (!slug || !execute || !inputParams || !name) {
      throw new Error("Invalid tool options");
    }
    const paramsSchema = await (0, import_zod_to_json_schema.default)(inputParams, {
      name: "input"
    });
    const paramsSchemaJson = paramsSchema.definitions.input;
    const toolSchema = {
      name,
      slug,
      description,
      inputParameters: {
        title: name,
        type: "object",
        description,
        properties: paramsSchemaJson.properties,
        required: paramsSchemaJson.required
      },
      // the output parameters are not used yet
      outputParameters: {
        type: "object",
        title: `Response for ${name}`,
        properties: {}
      },
      tags: [],
      // this is never set to the user provided toolkitslug so that we can differentiate
      // the toolkitslug is used via the execute function.
      toolkit: { name: "custom", slug: "custom" }
    };
    this.customToolsRegistry.set(slug.toLowerCase(), {
      options: toolOptions,
      schema: toolSchema
    });
    return toolSchema;
  }
  /**
   * Get all the custom tools from the registry.
   * @param {string[]} param0.toolSlugs The slugs of the tools to get
   * @returns {ToolList} The list of tools
   *
   * @example
   * ```typescript
   * // Get all custom tools
   * const allTools = await composio.customTools.getCustomTools({});
   *
   * // Get specific custom tools by slug
   * const specificTools = await composio.customTools.getCustomTools({
   *   toolSlugs: ['MY_CUSTOM_TOOL', 'ANOTHER_CUSTOM_TOOL']
   * });
   * ```
   */
  async getCustomTools({ toolSlugs }) {
    const tools = [];
    if (toolSlugs) {
      for (const slug of toolSlugs) {
        const tool = this.customToolsRegistry.get(slug.toLowerCase());
        if (tool) {
          tools.push(tool.schema);
        }
      }
    } else {
      return Array.from(this.customToolsRegistry.values()).map((tool) => tool.schema);
    }
    return tools;
  }
  /**
   * Get a custom tool by slug from the registry.
   * @param {string} slug The slug of the tool to get
   * @returns {Tool} The tool
   *
   * @example
   * ```typescript
   * // Get a specific custom tool by its slug
   * const myTool = await composio.customTools.getCustomToolBySlug('MY_CUSTOM_TOOL');
   * if (myTool) {
   *   console.log(`Found tool: ${myTool.name}`);
   * } else {
   *   console.log('Tool not found');
   * }
   * ```
   */
  async getCustomToolBySlug(slug) {
    if (!slug) {
      throw new Error("Tool slug is required");
    }
    try {
      const tool = this.customToolsRegistry.get(slug.toLowerCase());
      return tool?.schema;
    } catch (error) {
      logger_default.error(`Error getting custom tool: ${error}`);
      return void 0;
    }
  }
  /**
   * Get the connected account for the user and toolkit.
   * @param {string} toolkitSlug The slug of the toolkit
   * @param {ExecuteMetadata} metadata The metadata of the execution
   * @returns {ConnectedAccount} The connected account
   */
  async getConnectedAccountForToolkit(toolkitSlug, userId, connectedAccountId) {
    try {
      await this.client.toolkits.retrieve(toolkitSlug);
      const toolkit = await this.client.toolkits.retrieve(toolkitSlug);
      const isNoAuthToolkit = toolkit.auth_config_details?.some(
        (details) => details.mode === AuthSchemeTypes.NO_AUTH
      );
      if (isNoAuthToolkit) {
        return null;
      }
    } catch (error) {
      throw new ComposioToolNotFoundError(`Toolkit with slug ${toolkitSlug} not found`, {
        cause: error
      });
    }
    const connectedAccounts = await this.client.connectedAccounts.list({
      toolkit_slugs: [toolkitSlug],
      user_ids: [userId]
    });
    if (!connectedAccounts.items.length) {
      throw new ComposioConnectedAccountNotFoundError(
        `No connected accounts found for toolkit ${toolkitSlug}`
      );
    }
    const connectedAccount = connectedAccountId ? connectedAccounts.items.find((item) => item.id === connectedAccountId) : connectedAccounts.items[0];
    if (!connectedAccount) {
      throw new ComposioConnectedAccountNotFoundError(
        `Connected account not found for toolkit ${toolkitSlug} for user ${userId}`
      );
    }
    return transformConnectedAccountResponse(connectedAccount);
  }
  /**
   * Execute a custom tool
   *
   * @description If a toolkit is used, the connected account id is used to execute the tool.
   * If a connected account id is provided, it is used to execute the tool.
   * If a connected account id is not provided, the first connected account for the toolkit is used.
   *
   * @param {slug} slug The slug of the tool to execute
   * @param {Record<string, unknown>} inputParams The input parameters for the tool
   * @param {ExecuteMetadata} metadata The metadata of the execution
   * @returns {Promise<ToolExecuteResponse>} The response from the tool
   */
  async executeCustomTool(slug, body) {
    const tool = this.customToolsRegistry.get(slug.toLowerCase());
    if (!tool) {
      throw new ComposioToolNotFoundError(`Tool with slug ${slug} not found`);
    }
    let connectionConfig = null;
    const { toolkitSlug, execute, inputParams } = tool.options;
    let connectedAccountId = body.connectedAccountId;
    if (toolkitSlug && toolkitSlug !== "custom" && body.userId) {
      const connectedAccount = await this.getConnectedAccountForToolkit(
        toolkitSlug,
        body.userId,
        body.connectedAccountId
      );
      logger_default.debug(
        `[CustomTool] Connected account for ${toolkitSlug} found for user ${body.userId}`,
        JSON.stringify(connectedAccount, null, 2)
      );
      if (!connectedAccount) {
        throw new ComposioConnectedAccountNotFoundError(
          `Connected account not found for toolkit ${toolkitSlug} for user ${body.userId}`,
          {
            meta: {
              toolkitSlug,
              userId: body.userId
            }
          }
        );
      }
      connectionConfig = connectedAccount.state ?? null;
      connectedAccountId = connectedAccount.id;
    }
    if (typeof execute !== "function") {
      throw new ComposioInvalidExecuteFunctionError("Invalid execute function", {
        meta: {
          toolSlug: slug
        }
      });
    }
    const executeToolRequest = async (data) => {
      if (toolkitSlug && toolkitSlug === "custom") {
        throw new ComposioInvalidExecuteFunctionError(
          "Custom tools without a toolkit cannot be executed using the executeToolRequest function",
          {
            possibleFixes: [
              "Please manually execute the tool using your logic.",
              "Pass a toolkit slug to execute the tool on behalf of a toolkit credentials"
            ]
          }
        );
      }
      const parameters = data.parameters?.map((param) => ({
        name: param.name,
        type: param.in,
        value: param.value.toString()
      }));
      const response = await this.client.tools.proxy({
        endpoint: data.endpoint,
        method: data.method,
        parameters,
        body: data.body,
        connected_account_id: connectedAccountId,
        custom_connection_data: data.customConnectionData
      });
      return {
        data: response.data,
        error: null,
        successful: true,
        logId: void 0,
        sessionInfo: void 0
      };
    };
    const parsedInput = inputParams.safeParse(body.arguments);
    if (!parsedInput.success) {
      throw new ValidationError("Invalid input parameters", {
        cause: parsedInput.error
      });
    }
    return execute(parsedInput.data, connectionConfig, executeToolRequest);
  }
};

// src/errors/FileModifierErrors.ts
var FileModifierErrorCodes = {
  FILE_UPLOAD_FAILED: "FILE_UPLOAD_FAILED"
};
var ComposioFileUploadError = class extends ComposioError {
  constructor(message = "Failed to upload file", options = {}) {
    super(message, {
      ...options,
      code: FileModifierErrorCodes.FILE_UPLOAD_FAILED,
      possibleFixes: options.possibleFixes || ["Check if the file exists in the location provided"]
    });
    this.name = "ComposioFileUploadError";
  }
};

// src/utils/fileUtils.ts
var import_crypto = __toESM(require("crypto"), 1);
var import_path = __toESM(require("path"), 1);
var getExtensionFromMimeType = (mimeType) => {
  const mimeToExt = {
    "text/plain": "txt",
    "text/html": "html",
    "text/css": "css",
    "text/javascript": "js",
    "application/json": "json",
    "application/xml": "xml",
    "application/pdf": "pdf",
    "application/zip": "zip",
    "application/x-zip-compressed": "zip",
    "application/gzip": "gz",
    "application/x-tar": "tar",
    "application/msword": "doc",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
    "application/vnd.ms-excel": "xls",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
    "application/vnd.ms-powerpoint": "ppt",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": "pptx",
    "image/jpeg": "jpg",
    "image/jpg": "jpg",
    "image/png": "png",
    "image/gif": "gif",
    "image/svg+xml": "svg",
    "image/webp": "webp",
    "image/bmp": "bmp",
    "image/tiff": "tiff",
    "audio/mpeg": "mp3",
    "audio/wav": "wav",
    "audio/ogg": "ogg",
    "video/mp4": "mp4",
    "video/mpeg": "mpeg",
    "video/quicktime": "mov",
    "video/x-msvideo": "avi",
    "video/webm": "webm"
  };
  const cleanMimeType = mimeType.split(";")[0].toLowerCase().trim();
  if (mimeToExt[cleanMimeType]) {
    return mimeToExt[cleanMimeType];
  }
  const parts = cleanMimeType.split("/");
  if (parts.length === 2) {
    const subtype = parts[1].toLowerCase();
    const cleanSubtype = subtype;
    if (cleanSubtype.includes("+")) {
      const plusParts = cleanSubtype.split("+");
      const prefix = plusParts[0];
      const suffix = plusParts[plusParts.length - 1];
      const knownPrefixes = ["svg", "atom", "rss"];
      if (knownPrefixes.includes(prefix)) {
        return prefix;
      }
      const structuredSuffixes = ["json", "xml", "yaml", "zip", "gzip"];
      if (structuredSuffixes.includes(suffix)) {
        return suffix;
      }
      return suffix;
    }
    return cleanSubtype || "txt";
  }
  return "txt";
};
var generateTimestampedFilename = (extension, prefix) => {
  const basePrefix = prefix || "file_ts";
  return `${basePrefix}${Date.now()}${getRandomShortId()}.${extension}`;
};
var readFileContent = async (path) => {
  try {
    const content = require("fs").readFileSync(path);
    return {
      fileName: generateTimestampedFilename(path.split(".").pop() || "txt"),
      content: content.toString("base64"),
      mimeType: "application/octet-stream"
    };
  } catch (error) {
    throw new Error(`Error reading file at ${path}: ${error}`);
  }
};
var readFileContentFromURL = async (path) => {
  const response = await fetch(path);
  if (!response.ok) {
    throw new Error(`Failed to fetch file: ${response.statusText}`);
  }
  const arrayBuffer = await response.arrayBuffer();
  const content = Buffer.from(arrayBuffer);
  const mimeType = response.headers.get("content-type") || "application/octet-stream";
  const url = new URL(path);
  const pathname = url.pathname;
  let fileName = import_path.default.basename(pathname);
  if (!fileName || fileName === "/") {
    const extension = getExtensionFromMimeType(mimeType);
    fileName = generateTimestampedFilename(extension);
  } else {
    const hasExtension = fileName.includes(".");
    if (!hasExtension) {
      const extension = getExtensionFromMimeType(mimeType);
      fileName = generateTimestampedFilename(extension);
    }
  }
  return {
    content: content.toString("base64"),
    mimeType,
    fileName
  };
};
var uploadFileToS3 = async (fileName, content, toolSlug, toolkitSlug, mimeType, client) => {
  const response = await client.files.createPresignedURL({
    filename: fileName,
    mimetype: mimeType,
    md5: import_crypto.default.createHash("md5").update(Buffer.from(content, "base64")).digest("hex"),
    tool_slug: toolSlug,
    toolkit_slug: toolkitSlug
  });
  const { key, type } = response;
  if (type === "new" || type === "update") {
    logger_default.debug(`Uploading ${key} file to S3: ${key}`);
    const buffer = Buffer.from(content, "base64");
    const signedURL = response.type === "update" ? response.update_presigned_url : response.new_presigned_url;
    const uploadResponse = await fetch(signedURL, {
      method: "PUT",
      body: buffer,
      headers: {
        "Content-Type": mimeType,
        "Content-Length": buffer.length.toString()
      }
    });
    if (!uploadResponse.ok) {
      throw new Error(`Failed to upload file to S3: ${uploadResponse.statusText}`);
    }
  } else {
    logger_default.debug(`File already exists in S3: ${key}`);
  }
  return key;
};
var readFile = async (file) => {
  if (file instanceof File) {
    const content = await file.arrayBuffer();
    return {
      fileName: file.name,
      content: Buffer.from(content).toString("base64"),
      mimeType: file.type
    };
  } else if (typeof file === "string") {
    if (file.startsWith("http")) {
      return await readFileContentFromURL(file);
    } else {
      return await readFileContent(file);
    }
  }
  throw new Error("Invalid file type");
};
var getFileDataAfterUploadingToS3 = async (file, {
  toolSlug,
  toolkitSlug,
  client
}) => {
  if (!file) {
    throw new Error("Either path or blob must be provided");
  }
  const fileData = await readFile(file);
  logger_default.debug(`Uploading file to S3...`);
  const s3key = await uploadFileToS3(
    import_path.default.basename(fileData.fileName),
    fileData.content,
    toolSlug,
    toolkitSlug,
    fileData.mimeType,
    client
  );
  logger_default.debug(`Done! File uploaded to S3: ${s3key}`, JSON.stringify(fileData, null, 2));
  return {
    name: fileData.fileName,
    mimetype: fileData.mimeType,
    s3key
  };
};
var downloadFileFromS3 = async ({
  toolSlug,
  s3Url,
  mimeType
}) => {
  const response = await fetch(s3Url);
  if (!response.ok) {
    throw new Error(`Failed to download file: ${response.statusText}`);
  }
  const data = await response.arrayBuffer();
  const extension = getExtensionFromMimeType(mimeType);
  const fileName = generateTimestampedFilename(extension, `${toolSlug}_`);
  const filePath = saveFile(fileName, Buffer.from(data), true);
  return {
    name: fileName,
    mimeType,
    s3Url,
    filePath
  };
};
var getComposioDir = (createDirIfNotExists = false) => {
  try {
    const os = require("os");
    const path = require("path");
    const fs = require("fs");
    const composioDir = path.join(os.homedir(), COMPOSIO_DIR);
    if (createDirIfNotExists && !fs.existsSync(composioDir)) {
      fs.mkdirSync(composioDir, { recursive: true });
    }
    return composioDir;
  } catch (_error) {
    return null;
  }
};
var getComposioTempFilesDir = (createDirIfNotExists = false) => {
  try {
    const os = require("os");
    const path = require("path");
    const fs = require("fs");
    const composioFilesDir = path.join(os.homedir(), COMPOSIO_DIR, TEMP_FILES_DIRECTORY_NAME);
    if (createDirIfNotExists && !fs.existsSync(composioFilesDir)) {
      fs.mkdirSync(composioFilesDir, { recursive: true });
    }
    return composioFilesDir;
  } catch (_error) {
    return null;
  }
};
var saveFile = (file, content, isTempFile = false) => {
  try {
    const path = require("path");
    const fs = require("fs");
    const composioFilesDir = isTempFile ? getComposioTempFilesDir(true) : getComposioDir(true);
    const filePath = path.join(composioFilesDir, path.basename(file));
    logger_default.info(`Saving file to: ${filePath}`);
    if (Buffer.isBuffer(content)) {
      fs.writeFileSync(filePath, content);
    } else {
      fs.writeFileSync(filePath, content, "utf8");
    }
    return filePath;
  } catch (_error) {
    logger_default.debug(`Error saving file: ${_error}`);
    return null;
  }
};

// src/utils/modifiers/FileToolModifier.ts
var transformProperties = (properties) => {
  const newProperties = {};
  for (const [key, property] of Object.entries(properties)) {
    if (property.file_uploadable) {
      newProperties[key] = {
        title: property.title,
        description: property.description,
        format: "path",
        type: "string",
        file_uploadable: true
      };
    } else if (property.type === "object" && property.properties) {
      newProperties[key] = {
        ...property,
        properties: transformProperties(property.properties)
      };
    } else {
      newProperties[key] = property;
    }
  }
  return newProperties;
};
var hydrateFiles = async (value, schema, ctx) => {
  if (schema?.file_uploadable) {
    if (typeof value !== "string" && !(value instanceof File)) return value;
    logger_default.debug(`Uploading file "${value}"`);
    return getFileDataAfterUploadingToS3(value, {
      toolSlug: ctx.toolSlug,
      toolkitSlug: ctx.toolkitSlug,
      client: ctx.client
    });
  }
  if (schema?.type === "object" && schema.properties && isPlainObject(value)) {
    const transformed = {};
    for (const [k, v] of Object.entries(value)) {
      transformed[k] = await hydrateFiles(v, schema.properties[k], ctx);
    }
    return transformed;
  }
  if (schema?.type === "array" && schema.items && Array.isArray(value)) {
    const itemSchema = Array.isArray(schema.items) ? schema.items[0] : schema.items;
    return Promise.all(
      value.map((item) => hydrateFiles(item, itemSchema, ctx))
    );
  }
  return value;
};
var hydrateDownloads = async (value, ctx) => {
  if (isPlainObject(value) && typeof value.s3url === "string") {
    const { s3url, mimetype } = value;
    try {
      logger_default.debug(`Downloading from S3: ${s3url}`);
      const dl = await downloadFileFromS3({
        toolSlug: ctx.toolSlug,
        s3Url: s3url,
        mimeType: mimetype ?? "application/octet-stream"
      });
      logger_default.debug(`Downloaded \u2192 ${dl.filePath}`);
      return {
        uri: dl.filePath,
        file_downloaded: dl.filePath ? true : false,
        s3url,
        mimeType: dl.mimeType
      };
    } catch (err) {
      logger_default.error(`Download failed: ${s3url}`, { cause: err });
      return {
        uri: "",
        file_downloaded: false,
        s3url,
        mimeType: mimetype ?? "application/octet-stream"
      };
    }
  }
  if (isPlainObject(value)) {
    const pairs = await Promise.all(
      Object.entries(value).map(async ([k, v]) => [k, await hydrateDownloads(v, ctx)])
    );
    return Object.fromEntries(pairs);
  }
  if (Array.isArray(value)) {
    return Promise.all(value.map((item) => hydrateDownloads(item, ctx)));
  }
  return value;
};
function isPlainObject(val) {
  return typeof val === "object" && val !== null && !Array.isArray(val);
}
var FileToolModifier = class {
  client;
  constructor(client) {
    this.client = client;
  }
  /**
   * Modifies the tool schema to include the file upload URL.
   *
   * @description This modifier is used to upload a file to the Composio platform and replace the file path with the file upload URL.
   *
   * @param _toolSlug - The slug of the tool that is being executed.
   * @param _toolkitSlug - The slug of the toolkit that is being executed.
   * @param schema - The schema of the tool.
   * @returns The schema with the file upload URL included.
   */
  async modifyToolSchema(toolSlug, toolkitSlug, schema) {
    if (!schema.inputParameters?.properties) {
      return schema;
    }
    const properties = transformProperties(schema.inputParameters.properties);
    return {
      ...schema,
      inputParameters: {
        ...schema.inputParameters,
        properties
      }
    };
  }
  /**
   * Modifies the input parameters to include the file upload URL.
   *
   * @description This modifier is used to upload a file to the Composio platform and replace the file path with the file upload URL.
   *
   * @param toolSlug - The slug of the tool that is being executed.
   * @param toolkitSlug - The slug of the toolkit that is being executed.
   *
   */
  async fileUploadModifier(tool, options) {
    const { params, toolSlug, toolkitSlug = "unknown" } = options;
    const { arguments: args } = params;
    if (!args || typeof args !== "object") return params;
    try {
      const newArgs = await hydrateFiles(args, tool.inputParameters, {
        toolSlug,
        toolkitSlug,
        client: this.client
      });
      return { ...params, arguments: newArgs };
    } catch (error) {
      throw new ComposioFileUploadError("Failed to upload file", {
        cause: error
      });
    }
  }
  /**
   * Modifies the result to include the file download URL.
   *
   * @description This modifier is used to download a file and
   *
   * @param toolSlug - The slug of the tool that is being executed.
   * @param toolkitSlug - The slug of the toolkit that is being executed.
   * @param result - The result of the tool execution.
   * @returns The result with the file download URL included.
   */
  async fileDownloadModifier(_tool, options) {
    const { result, toolSlug } = options;
    const dataWithDownloads = await hydrateDownloads(result.data, { toolSlug });
    return { ...result, data: dataWithDownloads };
  }
};

// src/models/Tools.ts
var Tools = class {
  client;
  customTools;
  provider;
  autoUploadDownloadFiles;
  constructor(client, provider, options) {
    if (!client) {
      throw new Error("ComposioClient is required");
    }
    if (!provider) {
      throw new ComposioProviderNotDefinedError("Provider not passed into Tools instance");
    }
    this.client = client;
    this.customTools = new CustomTools(client);
    this.provider = provider;
    this.autoUploadDownloadFiles = options?.autoUploadDownloadFiles ?? true;
    this.execute = this.execute.bind(this);
    this.provider._setExecuteToolFn(this.execute);
    this.getRawComposioToolBySlug = this.getRawComposioToolBySlug.bind(this);
    this.getRawComposioTools = this.getRawComposioTools.bind(this);
    telemetry.instrument(this);
  }
  /**
   * Transforms tool data from snake_case API format to camelCase for internal SDK use.
   *
   * This method standardizes the property naming convention for tools retrieved from the Composio API,
   * making them more consistent with JavaScript/TypeScript conventions.
   *
   * @param {ToolRetrieveResponse | ComposioToolListResponse['items'][0]} tool - The tool object to transform
   * @returns {Tool} The transformed tool with camelCase properties
   *
   * @private
   */
  transformToolCases(tool) {
    return ToolSchema.parse({
      ...tool,
      inputParameters: tool.input_parameters,
      outputParameters: tool.output_parameters
    });
  }
  /**
   * Transforms tool execution response from snake_case API format to camelCase.
   *
   * This method converts the response received from the Composio API to a standardized format
   * with consistent property naming that follows JavaScript/TypeScript conventions.
   *
   * @param {ComposioToolExecuteResponse} response - The raw API response to transform
   * @returns {ToolExecuteResponse} The transformed response with camelCase properties
   *
   * @private
   */
  transformToolExecuteResponse(response) {
    return ToolExecuteResponseSchema.parse({
      data: response.data,
      error: response.error,
      successful: response.successful,
      logId: response.log_id,
      sessionInfo: response.session_info
    });
  }
  /**
   * Check if the connected account exists for the given tools.
   * @param {string} userId - The user id.
   * @param {ToolList} tools - The tools to check.
   * @returns {Promise<boolean>} True if the connected account exists for the given tools, false otherwise.
   */
  async checkIfConnectedAccountExistsForTools(userIds, tools) {
    if (!tools.length) {
      return true;
    }
    const connectedAccounts = await this.client.connectedAccounts.list({
      user_ids: userIds
    });
    if (connectedAccounts.items.length === 0) {
      return false;
    }
    const connectedToolkitSlugs = connectedAccounts.items.reduce(
      (acc, account) => {
        if (account.toolkit.slug) {
          acc[account.toolkit.slug] = true;
        }
        return acc;
      },
      {}
    );
    const toolSlugs = tools.reduce(
      (acc, tool) => {
        acc[tool.slug] = true;
        return acc;
      },
      {}
    );
    for (const tool of Object.keys(toolSlugs)) {
      if (!connectedToolkitSlugs[tool]) {
        logger_default.warn(`Tool ${tool} requires a connected account but no connected account was found`);
        return false;
      }
    }
    return true;
  }
  /**
   * Get the connected account id for a given tool
   * @param {string} userId - The user id
   * @param {string} toolSlug - The tool slug
   * @returns {Promise<string | null>} The connected account id or null if the toolkit is a no auth app
   */
  async getConnectedAccountIdForTool(userId, toolSlug) {
    const tool = await this.getRawComposioToolBySlug(toolSlug);
    if (!tool.toolkit) {
      throw new Error(`Unable to find toolkit for tool ${toolSlug}`);
    }
    const toolkit = await this.client.toolkits.retrieve(tool.toolkit.slug);
    if (!toolkit) {
      throw new Error(`Unable to find toolkit for tool ${toolSlug}`);
    }
    const isNoAuthApp = toolkit.auth_config_details?.some(
      (authConfigDetails) => authConfigDetails.mode === AuthSchemeTypes.NO_AUTH
    );
    if (!isNoAuthApp) {
      const connectedAccounts = await this.client.connectedAccounts.list({
        user_ids: [userId],
        toolkit_slugs: [tool.toolkit.slug]
      });
      if (connectedAccounts.items.length === 0) {
        throw new Error("No connected accounts found");
      }
      logger_default.warn(
        `Using the first connected account for tool ${toolSlug}. To change this behaviour please explicitly pass a connectedAccountId for the tool`
      );
      return connectedAccounts.items[0].id;
    }
    return null;
  }
  /**
   * Applies the default schema modifiers to the tools
   * @param tools - The tools to apply the default schema modifiers to
   * @returns The tools with the default schema modifiers applied
   */
  async applyDefaultSchemaModifiers(tools) {
    if (this.autoUploadDownloadFiles) {
      const fileToolModifier = new FileToolModifier(this.client);
      return await Promise.all(
        tools.map(
          (tool) => fileToolModifier.modifyToolSchema(tool.slug, tool.toolkit?.slug ?? "unknown", tool)
        )
      );
    } else {
      return tools;
    }
  }
  /**
   * Applies the before execute modifiers to the tool execution params
   * @param options.toolSlug - The slug of the tool
   * @param options.toolkitSlug - The slug of the toolkit
   * @param options.params - The params of the tool execution
   * @param modifier - The modifier to apply
   * @returns The modified params
   */
  async applyBeforeExecuteModifiers(tool, {
    toolSlug,
    toolkitSlug,
    params
  }, modifier) {
    let modifiedParams = params;
    if (this.autoUploadDownloadFiles) {
      const fileToolModifier = new FileToolModifier(this.client);
      modifiedParams = await fileToolModifier.fileUploadModifier(tool, {
        toolSlug,
        toolkitSlug,
        params: modifiedParams
      });
    }
    if (modifier) {
      if (typeof modifier === "function") {
        modifiedParams = await modifier({
          toolSlug,
          toolkitSlug,
          params: modifiedParams
        });
      } else {
        throw new ComposioInvalidModifierError("Invalid beforeExecute modifier. Not a function.");
      }
    }
    return modifiedParams;
  }
  /**
   * Applies the after execute modifiers to the tool execution result
   * @param options.toolSlug - The slug of the tool
   * @param options.toolkitSlug - The slug of the toolkit
   * @param options.result - The result of the tool execution
   * @param modifier - The modifier to apply
   * @returns The modified result
   */
  async applyAfterExecuteModifiers(tool, {
    toolSlug,
    toolkitSlug,
    result
  }, modifier) {
    let modifiedResult = result;
    if (this.autoUploadDownloadFiles) {
      const fileToolModifier = new FileToolModifier(this.client);
      modifiedResult = await fileToolModifier.fileDownloadModifier(tool, {
        toolSlug,
        toolkitSlug,
        result: modifiedResult
      });
    }
    if (modifier) {
      if (typeof modifier === "function") {
        modifiedResult = await modifier({
          toolSlug,
          toolkitSlug,
          result: modifiedResult
        });
      } else {
        throw new ComposioInvalidModifierError("Invalid afterExecute modifier. Not a function.");
      }
    }
    return modifiedResult;
  }
  /**
   * Lists all tools available in the Composio SDK including custom tools.
   *
   * This method fetches tools from the Composio API in raw format and combines them with
   * any registered custom tools. The response can be filtered and modified as needed.
   *
   * @param {ToolListParams} [query={}] - Optional query parameters to filter the tools
   * @param {TransformToolSchemaModifier} [modifier] - Optional function to transform tool schemas
   * @returns {Promise<ToolList>} List of tools matching the query criteria
   *
   * @example
   * ```typescript
   * // Get all tools
   * const tools = await composio.tools.getRawComposioTools();
   *
   * // Get tools with filters
   * const githubTools = await composio.tools.getRawComposioTools({
   *   toolkits: ['github'],
   *   limit: 10
   * });
   *
   * // Get tools with schema transformation
   * const tools = await composio.tools.getRawComposioTools({},
   *   (toolSlug, toolkitSlug, tool) => {
   *     // Add custom properties to tool schema
   *     return {...tool, customProperty: 'value'};
   *   }
   * );
   * ```
   */
  async getRawComposioTools(query, modifier) {
    if ("tools" in query && "toolkits" in query) {
      throw new ValidationError(
        "Invalid tool list parameters. You should not use tools and toolkits filter together."
      );
    }
    const queryParams = ToolListParamsSchema.safeParse(query);
    if (queryParams.error) {
      throw new ValidationError("Invalid tool list parameters", {
        cause: queryParams.error
      });
    }
    if (!("tools" in queryParams.data || "toolkits" in queryParams.data || "search" in queryParams.data || "authConfigIds" in queryParams.data)) {
      throw new ValidationError(
        "Invalid tool list parameters, atleast one of the following parameters is required: tools, toolkits, search, authConfigIds"
      );
    }
    let limit = "limit" in queryParams.data ? queryParams.data.limit : void 0;
    if ("tools" in queryParams.data) {
      limit = 9999;
    }
    const filters = {
      ..."tools" in queryParams.data ? { tool_slugs: queryParams.data.tools?.join(",") } : {},
      ..."toolkits" in queryParams.data ? { toolkit_slug: queryParams.data.toolkits?.join(",") } : {},
      ...limit ? { limit } : {},
      ..."tags" in queryParams.data ? { tags: queryParams.data.tags } : {},
      ..."scopes" in queryParams.data ? { scopes: queryParams.data.scopes } : {},
      ..."search" in queryParams.data ? { search: queryParams.data.search } : {},
      ..."authConfigIds" in queryParams.data ? { auth_config_ids: queryParams.data.authConfigIds } : {}
    };
    logger_default.debug(`Fetching tools with filters: ${JSON.stringify(filters, null, 2)}`);
    const tools = await this.client.tools.list(filters);
    if (!tools) {
      return [];
    }
    const caseTransformedTools = tools.items.map((tool) => this.transformToolCases(tool));
    const customTools = await this.customTools.getCustomTools({
      toolSlugs: "tools" in queryParams.data ? queryParams.data.tools : void 0
    });
    let modifiedTools = await this.applyDefaultSchemaModifiers([
      ...caseTransformedTools,
      ...customTools
    ]);
    if (modifier) {
      if (typeof modifier === "function") {
        const modifiedPromises = modifiedTools.map(
          (tool) => modifier({
            toolSlug: tool.slug,
            toolkitSlug: tool.toolkit?.slug ?? "unknown",
            schema: tool
          })
        );
        modifiedTools = await Promise.all(modifiedPromises);
      } else {
        throw new ComposioInvalidModifierError("Invalid schema modifier. Not a function.");
      }
    }
    return modifiedTools;
  }
  /**
   * Retrieves a tool by its Slug.
   * This method is used to get the raw tools from the composio API.
   * @param slug The ID of the tool to be retrieved
   * @returns {Promise<Tool>} The tool
   *
   * @example
   * ```ts
   * const tool = await composio.tools.getRawComposioToolBySlug('github');
   * ```
   */
  async getRawComposioToolBySlug(slug, modifier) {
    const customTool = await this.customTools.getCustomToolBySlug(slug);
    if (customTool) {
      logger_default.debug(`Found ${slug} to be a custom tool`, JSON.stringify(customTool, null, 2));
      return customTool;
    } else {
      logger_default.debug(`Tool ${slug} is not a custom tool. Fetching from Composio API`);
    }
    let tool;
    try {
      tool = await this.client.tools.retrieve(slug);
    } catch (error) {
      throw new ComposioToolNotFoundError(`Unable to retrieve tool with slug ${slug}`, {
        cause: error
      });
    }
    let [modifiedTool] = await this.applyDefaultSchemaModifiers([this.transformToolCases(tool)]);
    if (modifier) {
      if (typeof modifier === "function") {
        modifiedTool = await modifier({
          toolSlug: slug,
          toolkitSlug: modifiedTool.toolkit?.slug ?? "unknown",
          schema: modifiedTool
        });
      } else {
        throw new ComposioInvalidModifierError("Invalid schema modifier. Not a function.");
      }
    }
    return modifiedTool;
  }
  /**
   * Get a tool or list of tools based on the provided arguments.
   * This is an implementation method that handles both overloads.
   *
   * @param {string} userId - The user id to get the tool(s) for
   * @param {ToolListParams | string} arg2 - Either a slug string or filters object
   * @param {ProviderOptions<TProvider>} [options] - Optional provider options
   * @returns {Promise<TToolCollection>} The tool collection
   */
  async get(userId, arg2, options) {
    const executeToolFn = this.createExecuteToolFn(userId, options);
    if (typeof arg2 === "string") {
      const tool = await this.getRawComposioToolBySlug(arg2, options?.modifySchema);
      return this.provider.wrapTools([tool], executeToolFn);
    } else {
      const tools = await this.getRawComposioTools(arg2, options?.modifySchema);
      return this.provider.wrapTools(tools, executeToolFn);
    }
  }
  /**
   * @internal
   * @description
   * Creates a function that executes a tool.
   * This function is used by agentic providers to execute the tool
   *
   * @param {string} userId - The user id
   * @param {ExecuteToolModifiers} modifiers - The modifiers to be applied to the tool
   * @returns {ExecuteToolFn} The execute tool function
   */
  createExecuteToolFn(userId, modifiers) {
    const executeToolFn = async (toolSlug, input) => {
      return await this.execute(
        toolSlug,
        {
          userId,
          arguments: input
        },
        modifiers
      );
    };
    return executeToolFn;
  }
  /**
   * @internal
   * Handles the execution of a custom tool
   * @param tool - The tool to execute
   * @param body - The body of the tool execution
   * @param modifiers - The modifiers to be applied to the tool execution
   * @returns The response from the tool execution
   */
  async handleCustomToolExecution(tool, body, modifiers) {
    if (modifiers?.beforeExecute) {
      if (typeof modifiers.beforeExecute === "function") {
        body = await modifiers.beforeExecute({
          toolSlug: tool.slug,
          toolkitSlug: tool.toolkit?.slug ?? "unknown",
          params: body
        });
      } else {
        throw new ComposioInvalidModifierError("Invalid beforeExecute modifier. Not a function.");
      }
    }
    let result = await this.customTools.executeCustomTool(tool.slug, body);
    if (modifiers?.afterExecute) {
      if (typeof modifiers.afterExecute === "function") {
        result = await modifiers.afterExecute({
          toolSlug: tool.slug,
          toolkitSlug: tool.toolkit?.slug ?? "unknown",
          result
        });
      } else {
        throw new ComposioInvalidModifierError("Invalid afterExecute modifier. Not a function.");
      }
    }
    return result;
  }
  /**
   * @internal
   * Handles the execution of a composio tool
   * @param tool - The tool to execute
   * @param body - The body of the tool execution
   * @param modifiers - The modifiers to be applied to the tool execution
   * @returns The response from the tool execution
   */
  async handleComposioToolExecution(tool, body, modifiers) {
    body = await this.applyBeforeExecuteModifiers(
      tool,
      {
        toolSlug: tool.slug,
        toolkitSlug: tool.toolkit?.slug ?? "unknown",
        params: body
      },
      modifiers?.beforeExecute
    );
    let connectedAccountId = body.connectedAccountId;
    if (!connectedAccountId && body.userId) {
      connectedAccountId = await this.getConnectedAccountIdForTool(body.userId, tool.slug) || void 0;
    }
    let result = await this.client.tools.execute(tool.slug, {
      allow_tracing: body.allowTracing,
      connected_account_id: body.connectedAccountId,
      custom_auth_params: body.customAuthParams,
      custom_connection_data: body.customConnectionData,
      arguments: body.arguments,
      user_id: body.userId,
      version: body.version,
      text: body.text
    });
    result = this.transformToolExecuteResponse(result);
    result = await this.applyAfterExecuteModifiers(
      tool,
      {
        toolSlug: tool.slug,
        toolkitSlug: tool.toolkit?.slug ?? "unknown",
        result
      },
      modifiers?.afterExecute
    );
    return result;
  }
  /**
   * Executes a given tool with the provided parameters.
   *
   * This method calls the Composio API or a custom tool handler to execute the tool and returns the response.
   * It automatically determines whether to use a custom tool or a Composio API tool based on the slug.
   *
   * @param {string} slug - The slug/ID of the tool to be executed
   * @param {ToolExecuteParams} body - The parameters to be passed to the tool
   * @param {ExecuteToolModifiers} [modifiers] - Optional modifiers to transform the request or response
   * @returns {Promise<ToolExecuteResponse>} - The response from the tool execution
   *
   * @throws {ComposioCustomToolsNotInitializedError} If the CustomTools instance is not initialized
   * @throws {ComposioToolNotFoundError} If the tool with the given slug is not found
   * @throws {ComposioToolExecutionError} If there is an error during tool execution
   *
   * @example
   * ```typescript
   * // Execute a Composio API tool
   * const result = await composio.tools.execute('HACKERNEWS_GET_USER', {
   *   userId: 'default',
   *   arguments: { userId: 'pg' }
   * });
   *
   * // Execute with modifiers
   * const result = await composio.tools.execute('GITHUB_GET_ISSUES', {
   *   userId: 'default',
   *   arguments: { owner: 'composio', repo: 'sdk' }
   * }, {
   *   beforeExecute: (toolSlug, toolkitSlug, params) => {
   *     // Modify params before execution
   *     return params;
   *   },
   *   afterExecute: (toolSlug, toolkitSlug, result) => {
   *     // Transform result after execution
   *     return result;
   *   }
   * });
   * ```
   */
  async execute(slug, body, modifiers) {
    if (!this.customTools) {
      throw new ComposioCustomToolsNotInitializedError(
        "CustomTools not initialized. Make sure Tools class is properly constructed."
      );
    }
    try {
      const customTool = await this.customTools.getCustomToolBySlug(slug);
      if (customTool) {
        return this.handleCustomToolExecution(customTool, body, modifiers);
      } else {
        const composioTool = await this.getRawComposioToolBySlug(slug);
        if (!composioTool) {
          throw new ComposioToolNotFoundError(`Tool with slug ${slug} not found`);
        }
        return this.handleComposioToolExecution(composioTool, body, modifiers);
      }
    } catch (error) {
      throw new ComposioToolExecutionError(`Error executing tool ${slug}`, {
        originalError: error,
        meta: {
          toolSlug: slug,
          body
        }
      });
    }
  }
  /**
   * Fetches the list of all available tools in the Composio SDK.
   *
   * This method is mostly used by the CLI to get the list of tools.
   * No filtering is done on the tools, the list is cached in the backend, no further optimization is required.
   * @returns {Promise<ToolRetrieveEnumResponse>} The complete list of all available tools with their metadata
   *
   * @example
   * ```typescript
   * // Get all available tools as an enum
   * const toolsEnum = await composio.tools.getToolsEnum();
   * console.log(toolsEnum.items);
   * ```
   */
  async getToolsEnum() {
    return this.client.tools.retrieveEnum();
  }
  /**
   * Fetches the input parameters for a given tool.
   *
   * This method is used to get the input parameters for a tool before executing it.
   *
   * @param {string} slug - The ID of the tool to find input for
   * @param {ToolGetInputParams} body - The parameters to be passed to the tool
   * @returns {Promise<ToolGetInputResponse>} The input parameters schema for the specified tool
   *
   * @example
   * ```typescript
   * // Get input parameters for a specific tool
   * const inputParams = await composio.tools.getInput('GITHUB_CREATE_ISSUE', {
   *   userId: 'default'
   * });
   * console.log(inputParams.schema);
   * ```
   */
  async getInput(slug, body) {
    return this.client.tools.getInput(slug, body);
  }
  /**
   * Proxies a custom request to a toolkit/integration.
   *
   * This method allows sending custom requests to a specific toolkit or integration
   * when you need more flexibility than the standard tool execution methods provide.
   *
   * @param {ToolProxyParams} body - The parameters for the proxy request including toolkit slug and custom data
   * @returns {Promise<ToolProxyResponse>} The response from the proxied request
   *
   * @example
   * ```typescript
   * // Send a custom request to a toolkit
   * const response = await composio.tools.proxyExecute({
   *   toolkitSlug: 'github',
   *   userId: 'default',
   *   data: {
   *     endpoint: '/repos/owner/repo/issues',
   *     method: 'GET'
   *   }
   * });
   * console.log(response.data);
   * ```
   */
  async proxyExecute(body) {
    const toolProxyParams = ToolProxyParamsSchema.safeParse(body);
    if (!toolProxyParams.success) {
      throw new ValidationError("Invalid tool proxy parameters", { cause: toolProxyParams.error });
    }
    const parameters = [];
    const parameterTypes = {
      header: "header",
      query: "query"
    };
    if (toolProxyParams.data.parameters) {
      parameters.push(
        ...(toolProxyParams.data.parameters ?? []).map((value) => ({
          name: value.name,
          type: value.in === "header" ? parameterTypes.header : parameterTypes.query,
          value: value.value.toString()
        }))
      );
    }
    return this.client.tools.proxy({
      endpoint: toolProxyParams.data.endpoint,
      method: toolProxyParams.data.method,
      body: toolProxyParams.data.body,
      connected_account_id: toolProxyParams.data.connectedAccountId,
      parameters,
      custom_connection_data: toolProxyParams.data.customConnectionData
    });
  }
  /**
   * Creates a custom tool that can be used within the Composio SDK.
   *
   * Custom tools allow you to extend the functionality of Composio with your own implementations
   * while keeping a consistent interface for both built-in and custom tools.
   *
   * @param {CustomToolOptions} body - The configuration for the custom tool
   * @returns {Promise<Tool>} The created custom tool
   *
   * @example
   * ```typescript
   * // creating a custom tool with a toolkit
   * await composio.tools.createCustomTool({
   *   name: 'My Custom Tool',
   *   description: 'A custom tool that does something specific',
   *   slug: 'MY_CUSTOM_TOOL',
   *   userId: 'default',
   *   connectedAccountId: '123',
   *   toolkitSlug: 'github',
   *   inputParameters: z.object({
   *     param1: z.string().describe('First parameter'),
   *   }),
   *   execute: async (input, connectionConfig, executeToolRequest) => {
   *     // Custom logic here
   *     return { data: { result: 'Success!' } };
   *   }
   * });
   * ```
   *
   * @example
   * ```typescript
   * // creating a custom tool without a toolkit
   * await composio.tools.createCustomTool({
   *   name: 'My Custom Tool',
   *   description: 'A custom tool that does something specific',
   *   slug: 'MY_CUSTOM_TOOL',
   *   inputParameters: z.object({
   *     param1: z.string().describe('First parameter'),
   *   }),
   *   execute: async (input) => {
   *     // Custom logic here
   *     return { data: { result: 'Success!' } };
   *   }
   * });
   */
  async createCustomTool(body) {
    return this.customTools.createTool(body);
  }
};

// src/models/Toolkits.ts
var import_client4 = __toESM(require("@composio/client"), 1);

// src/types/toolkit.types.ts
var import_zod7 = require("zod");
var ToolkitMangedByEnumSchema = import_zod7.z.enum(["all", "composio", "project"]);
var ToolkitSortByEnumSchema = import_zod7.z.enum(["usage", "alphabetically"]);
var ToolkitsListParamsSchema = import_zod7.z.object({
  category: import_zod7.z.string().optional(),
  isLocal: import_zod7.z.boolean().optional(),
  managedBy: ToolkitMangedByEnumSchema.optional(),
  sortBy: ToolkitSortByEnumSchema.optional()
});
var ToolKitMetaSchema = import_zod7.z.object({
  categories: import_zod7.z.array(
    import_zod7.z.object({
      slug: import_zod7.z.string(),
      name: import_zod7.z.string()
    })
  ).optional(),
  appUrl: import_zod7.z.string().optional(),
  createdAt: import_zod7.z.string().optional(),
  description: import_zod7.z.string().optional(),
  logo: import_zod7.z.string().optional(),
  toolsCount: import_zod7.z.number().optional(),
  triggersCount: import_zod7.z.number().optional(),
  updatedAt: import_zod7.z.string().optional()
});
var ToolKitItemSchema = import_zod7.z.object({
  name: import_zod7.z.string(),
  slug: import_zod7.z.string(),
  meta: ToolKitMetaSchema,
  isLocalToolkit: import_zod7.z.boolean(),
  authSchemes: import_zod7.z.array(import_zod7.z.string()).optional(),
  composioManagedAuthSchemes: import_zod7.z.array(import_zod7.z.string()).optional(),
  noAuth: import_zod7.z.boolean().optional()
});
var ToolKitListResponseSchema = import_zod7.z.array(ToolKitItemSchema);
var ToolkitAuthFieldSchema = import_zod7.z.object({
  name: import_zod7.z.string(),
  displayName: import_zod7.z.string(),
  type: import_zod7.z.string(),
  default: import_zod7.z.string().nullable().optional()
});
var ToolkitAuthConfigDetailsSchema = import_zod7.z.object({
  name: import_zod7.z.string(),
  mode: import_zod7.z.string(),
  fields: import_zod7.z.object({
    authConfigCreation: import_zod7.z.object({
      optional: import_zod7.z.array(ToolkitAuthFieldSchema),
      required: import_zod7.z.array(ToolkitAuthFieldSchema)
    }),
    connectedAccountInitiation: import_zod7.z.object({
      optional: import_zod7.z.array(ToolkitAuthFieldSchema),
      required: import_zod7.z.array(ToolkitAuthFieldSchema)
    })
  }),
  proxy: import_zod7.z.object({
    baseUrl: import_zod7.z.string().optional()
  }).optional()
});
var ToolkitRetrieveResponseSchema = import_zod7.z.object({
  name: import_zod7.z.string(),
  slug: import_zod7.z.string(),
  meta: ToolKitMetaSchema,
  isLocalToolkit: import_zod7.z.boolean(),
  composioManagedAuthSchemes: import_zod7.z.array(import_zod7.z.string()).optional(),
  authConfigDetails: import_zod7.z.array(ToolkitAuthConfigDetailsSchema).optional(),
  baseUrl: import_zod7.z.string().optional(),
  getCurrentUserEndpoint: import_zod7.z.string().optional()
});
var ToolkitCategorySchema = import_zod7.z.object({
  id: import_zod7.z.string(),
  name: import_zod7.z.string()
});
var ToolkitRetrieveCategoriesResponseSchema = import_zod7.z.object({
  items: import_zod7.z.array(ToolkitCategorySchema),
  nextCursor: import_zod7.z.string().nullable(),
  totalPages: import_zod7.z.number()
});
var ToolkitAuthFieldsResponseSchema = import_zod7.z.array(
  ToolkitAuthFieldSchema.extend({
    required: import_zod7.z.boolean().optional()
  })
);

// src/utils/transformers/authConfigs.ts
function transformAuthConfigRetrieveResponse(authConfig) {
  return transform(authConfig).with(AuthConfigRetrieveResponseSchema).using((authConfig2) => ({
    id: authConfig2.id,
    name: authConfig2.name,
    noOfConnections: authConfig2.no_of_connections,
    status: authConfig2.status,
    toolkit: {
      logo: authConfig2.toolkit.logo,
      slug: authConfig2.toolkit.slug
    },
    uuid: authConfig2.uuid,
    authScheme: authConfig2.auth_scheme,
    credentials: authConfig2.credentials,
    expectedInputFields: authConfig2.expected_input_fields,
    isComposioManaged: authConfig2.is_composio_managed,
    createdBy: authConfig2.created_by,
    createdAt: authConfig2.created_at,
    lastUpdatedAt: authConfig2.last_updated_at,
    restrictToFollowingTools: authConfig2.tool_access_config?.tools_for_connected_account_creation,
    toolAccessConfig: authConfig2.tool_access_config ? {
      toolsAvailableForExecution: authConfig2.tool_access_config.tools_available_for_execution,
      toolsForConnectedAccountCreation: authConfig2.tool_access_config.tools_for_connected_account_creation
    } : void 0
  }));
}
function transformAuthConfigListResponse(response) {
  return transform(response).with(AuthConfigListResponseSchema).using((response2) => ({
    items: response2.items.map(transformAuthConfigRetrieveResponse),
    nextCursor: response2.next_cursor ?? null,
    totalPages: response2.total_pages
  }));
}
function transformCreateAuthConfigResponse(response) {
  return transform(response).with(CreateAuthConfigResponseSchema).using((response2) => ({
    id: response2.auth_config.id,
    authScheme: response2.auth_config.auth_scheme,
    isComposioManaged: response2.auth_config.is_composio_managed,
    toolkit: response2.toolkit.slug
  }));
}

// src/models/AuthConfigs.ts
var AuthConfigs = class {
  client;
  constructor(client) {
    this.client = client;
    telemetry.instrument(this);
  }
  /**
   * Protected getter for the client instance.
   * This is primarily used for testing purposes.
   * @protected
   */
  getClient() {
    return this.client;
  }
  /**
   * Lists authentication configurations based on provided filter criteria.
   *
   * This method retrieves auth configs from the Composio API, transforms them to the SDK format,
   * and supports filtering by various parameters.
   *
   * @param {AuthConfigListParams} [query] - Optional query parameters for filtering auth configs
   * @returns {Promise<AuthConfigListResponse>} A paginated list of auth configurations
   * @throws {ValidationError} If the query parameters or response fail validation
   *
   * @example
   * ```typescript
   * // List all auth configs
   * const allConfigs = await composio.authConfigs.list();
   *
   * // List auth configs for a specific toolkit
   * const githubConfigs = await composio.authConfigs.list({
   *   toolkit: 'github'
   * });
   *
   * // List Composio-managed auth configs
   * const managedConfigs = await composio.authConfigs.list({
   *   isComposioManaged: true
   * });
   * ```
   */
  async list(query) {
    const parsedQuery = query ? AuthConfigListParamsSchema.parse(query) : void 0;
    const result = await this.client.authConfigs.list({
      cursor: parsedQuery?.cursor,
      is_composio_managed: parsedQuery?.isComposioManaged,
      limit: parsedQuery?.limit,
      toolkit_slug: parsedQuery?.toolkit
    });
    return transformAuthConfigListResponse(result);
  }
  /**
   * Create a new auth config
   * @param {string} toolkit - Unique identifier of the toolkit
   * @param {CreateAuthConfigParams} options - Options for creating a new auth config
   * @returns {Promise<CreateAuthConfigResponse>} Created auth config
   *
   * @example
   * const authConfig = await authConfigs.create('my-toolkit', {
   *   type: AuthConfigTypes.CUSTOM,
   *   name: 'My Custom Auth Config',
   *   authScheme: AuthSchemeTypes.API_KEY,
   *   credentials: {
   *     apiKey: '1234567890',
   *   },
   * });
   *
   * @link https://docs.composio.dev/reference/auth-configs/create-auth-config
   */
  async create(toolkit, options = { type: "use_composio_managed_auth" }) {
    const parsedOptions = CreateAuthConfigParamsSchema.safeParse(options);
    if (parsedOptions.error) {
      throw new ValidationError("Failed to parse auth config create options", {
        cause: parsedOptions.error
      });
    }
    const result = await this.client.authConfigs.create({
      toolkit: {
        slug: toolkit
      },
      auth_config: parsedOptions.data.type === "use_custom_auth" ? {
        type: parsedOptions.data.type,
        name: parsedOptions.data.name,
        authScheme: parsedOptions.data.authScheme,
        credentials: parsedOptions.data.credentials,
        proxy_config: parsedOptions.data.proxyConfig ? {
          proxy_url: parsedOptions.data.proxyConfig.proxyUrl,
          proxy_auth_key: parsedOptions.data.proxyConfig.proxyAuthKey
        } : void 0,
        tool_access_config: parsedOptions.data.toolAccessConfig ? {
          tools_for_connected_account_creation: parsedOptions.data.toolAccessConfig.toolsForConnectedAccountCreation
        } : void 0
      } : {
        type: parsedOptions.data.type,
        credentials: parsedOptions.data.credentials,
        name: parsedOptions.data.name,
        tool_access_config: parsedOptions.data.toolAccessConfig ? {
          tools_for_connected_account_creation: parsedOptions.data.toolAccessConfig.toolsForConnectedAccountCreation
        } : void 0
      }
    });
    return transformCreateAuthConfigResponse(result);
  }
  /**
   * Retrieves a specific authentication configuration by its ID.
   *
   * This method fetches detailed information about a single auth config
   * and transforms the response to the SDK's standardized format.
   *
   * @param {string} nanoid - The unique identifier of the auth config to retrieve
   * @returns {Promise<AuthConfigRetrieveResponse>} The auth config details
   * @throws {Error} If the auth config cannot be found or an API error occurs
   * @throws {ValidationError} If the response fails validation
   *
   * @example
   * ```typescript
   * // Get an auth config by ID
   * const authConfig = await composio.authConfigs.get('auth_abc123');
   * console.log(authConfig.name); // e.g., 'GitHub Auth'
   * console.log(authConfig.toolkit.slug); // e.g., 'github'
   * ```
   */
  async get(nanoid) {
    const result = await this.client.authConfigs.retrieve(nanoid);
    return transformAuthConfigRetrieveResponse(result);
  }
  /**
   * Updates an existing authentication configuration.
   *
   * This method allows you to modify properties of an auth config such as credentials,
   * scopes, or tool restrictions. The update type (custom or default) determines which
   * fields can be updated.
   *
   * @param {string} nanoid - The unique identifier of the auth config to update
   * @param {AuthConfigUpdateParams} data - The data to update, which can be either custom or default type
   * @returns {Promise<AuthConfigUpdateResponse>} The updated auth config
   * @throws {ValidationError} If the update parameters are invalid
   * @throws {Error} If the auth config cannot be found or updated
   *
   * @example
   * ```typescript
   * // Update a custom auth config with new credentials
   * const updatedConfig = await composio.authConfigs.update('auth_abc123', {
   *   type: 'custom',
   *   credentials: {
   *     apiKey: 'new-api-key-value'
   *   }
   * });
   *
   * // Update a default auth config with new scopes
   * const updatedConfig = await composio.authConfigs.update('auth_abc123', {
   *   type: 'default',
   *   scopes: ['read:user', 'repo']
   * });
   * ```
   */
  async update(nanoid, data) {
    const parsedData = AuthConfigUpdateParamsSchema.safeParse(data);
    if (parsedData.error) {
      throw new ValidationError("Failed to parse auth config update data", {
        cause: parsedData.error
      });
    }
    return this.client.authConfigs.update(
      nanoid,
      parsedData.data.type === "custom" ? {
        type: "custom",
        credentials: parsedData.data.credentials,
        tool_access_config: {
          tools_for_connected_account_creation: parsedData.data.toolAccessConfig?.toolsForConnectedAccountCreation,
          tools_available_for_execution: parsedData.data.toolAccessConfig?.toolsAvailableForExecution ?? parsedData.data.restrictToFollowingTools
        }
      } : {
        type: "default",
        scopes: parsedData.data.scopes,
        tool_access_config: {
          tools_for_connected_account_creation: parsedData.data.toolAccessConfig?.toolsForConnectedAccountCreation,
          tools_available_for_execution: parsedData.data.toolAccessConfig?.toolsAvailableForExecution ?? parsedData.data.restrictToFollowingTools
        }
      }
    );
  }
  /**
   * Deletes an authentication configuration.
   *
   * This method permanently removes an auth config from the Composio platform.
   * This action cannot be undone and will prevent any connected accounts that use
   * this auth config from functioning.
   *
   * @param {string} nanoid - The unique identifier of the auth config to delete
   * @returns {Promise<AuthConfigDeleteResponse>} The deletion response
   * @throws {Error} If the auth config doesn't exist or cannot be deleted
   *
   * @example
   * ```typescript
   * // Delete an auth config
   * await composio.authConfigs.delete('auth_abc123');
   * ```
   */
  async delete(nanoid) {
    return this.client.authConfigs.delete(nanoid);
  }
  /**
   * Updates the status of an authentication configuration.
   *
   * This method allows you to enable or disable an auth config. When disabled,
   * the auth config cannot be used to create new connected accounts or authenticate
   * with third-party services.
   *
   * @param {string} status - The status to set ('ENABLED' or 'DISABLED')
   * @param {string} nanoid - The unique identifier of the auth config
   * @returns {Promise<AuthConfigUpdateStatusResponse>} The updated auth config details
   * @throws {Error} If the auth config cannot be found or the status cannot be updated
   *
   * @example
   * ```typescript
   * // Disable an auth config
   * await composio.authConfigs.updateStatus('DISABLED', 'auth_abc123');
   *
   * // Enable an auth config
   * await composio.authConfigs.updateStatus('ENABLED', 'auth_abc123');
   * ```
   */
  async updateStatus(status, nanoid) {
    return this.client.authConfigs.updateStatus(status, { nanoid });
  }
  /**
   * Enables an authentication configuration.
   *
   * This is a convenience method that calls updateStatus with 'ENABLED'.
   * When enabled, the auth config can be used to create new connected accounts
   * and authenticate with third-party services.
   *
   * @param {string} nanoid - The unique identifier of the auth config to enable
   * @returns {Promise<AuthConfigUpdateStatusResponse>} The updated auth config details
   * @throws {Error} If the auth config cannot be found or enabled
   *
   * @example
   * ```typescript
   * // Enable an auth config
   * await composio.authConfigs.enable('auth_abc123');
   * ```
   */
  async enable(nanoid) {
    return this.client.authConfigs.updateStatus("ENABLED", { nanoid });
  }
  /**
   * Disables an authentication configuration.
   *
   * This is a convenience method that calls updateStatus with 'DISABLED'.
   * When disabled, the auth config cannot be used to create new connected accounts
   * or authenticate with third-party services, but existing connections may continue to work.
   *
   * @param {string} nanoid - The unique identifier of the auth config to disable
   * @returns {Promise<AuthConfigUpdateStatusResponse>} The updated auth config details
   * @throws {Error} If the auth config cannot be found or disabled
   *
   * @example
   * ```typescript
   * // Disable an auth config
   * await composio.authConfigs.disable('auth_abc123');
   * ```
   */
  async disable(nanoid) {
    return this.client.authConfigs.updateStatus("DISABLED", { nanoid });
  }
};

// src/models/ConnectionRequest.ts
var import_client3 = __toESM(require("@composio/client"), 1);
function createConnectionRequest(client, connectedAccountId, status, redirectUrl) {
  const state = {
    id: connectedAccountId,
    status: status || ConnectedAccountStatuses.INITIATED,
    redirectUrl
  };
  telemetry.instrument(state);
  async function waitForConnection(timeout = 6e4) {
    try {
      const response = await client.connectedAccounts.retrieve(state.id);
      if (response.status === ConnectedAccountStatuses.ACTIVE) {
        state.status = ConnectedAccountStatuses.ACTIVE;
        return transformConnectedAccountResponse(response);
      }
    } catch (error) {
      if (error instanceof import_client3.default.NotFoundError) {
        throw new ComposioConnectedAccountNotFoundError(
          `Connected account with id ${state.id} not found`,
          {
            meta: {
              connectedAccountId: state.id
            }
          }
        );
      } else {
        throw error;
      }
    }
    const terminalErrorStates = [
      ConnectedAccountStatuses.FAILED,
      ConnectedAccountStatuses.EXPIRED
    ];
    const start = Date.now();
    const pollInterval = 1e3;
    while (Date.now() - start < timeout) {
      try {
        const response = await client.connectedAccounts.retrieve(state.id);
        state.status = response.status;
        if (response.status === ConnectedAccountStatuses.ACTIVE) {
          return transformConnectedAccountResponse(response);
        }
        if (terminalErrorStates.includes(response.status)) {
          throw new ConnectionRequestFailedError(
            `Connection request failed with status: ${response.status}${response.status_reason ? `, reason: ${response.status_reason}` : ""}`,
            {
              meta: {
                connectedAccountId: state.id,
                status: response.status,
                statusReason: response.status_reason
              }
            }
          );
        }
        await new Promise((resolve) => setTimeout(resolve, pollInterval));
      } catch (error) {
        throw error;
      }
    }
    throw new ConnectionRequestTimeoutError(`Connection request timed out for ${state.id}`);
  }
  return {
    ...state,
    waitForConnection,
    toJSON: () => ({ ...state }),
    toString: () => JSON.stringify(state, null, 2)
  };
}

// src/models/ConnectedAccounts.ts
var ConnectedAccounts = class {
  client;
  constructor(client) {
    this.client = client;
    telemetry.instrument(this);
  }
  /**
   * Lists all connected accounts based on provided filter criteria.
   *
   * This method retrieves connected accounts from the Composio API with optional filtering.
   *
   * @param {ConnectedAccountListParams} [query] - Optional query parameters for filtering connected accounts
   * @returns {Promise<ConnectedAccountListResponse>} A paginated list of connected accounts
   * @throws {ValidationError} If the query fails validation against the expected schema
   * @example
   * ```typescript
   * // List all connected accounts
   * const allAccounts = await composio.connectedAccounts.list();
   *
   * // List accounts for a specific user
   * const userAccounts = await composio.connectedAccounts.list({
   *   userIds: ['user123']
   * });
   *
   * // List accounts for a specific toolkit
   * const githubAccounts = await composio.connectedAccounts.list({
   *   toolkitSlugs: ['github']
   * });
   * ```
   */
  async list(query) {
    let rawQuery = void 0;
    if (query) {
      const parsedQuery = ConnectedAccountListParamsSchema.safeParse(query);
      if (!parsedQuery.success) {
        throw new ValidationError("Failed to parse connected account list query", {
          cause: parsedQuery.error
        });
      }
      rawQuery = {
        auth_config_ids: parsedQuery.data.authConfigIds,
        cursor: parsedQuery.data.cursor?.toString(),
        labels: parsedQuery.data.labels,
        limit: parsedQuery.data.limit,
        order_by: parsedQuery.data.orderBy,
        statuses: parsedQuery.data.statuses,
        toolkit_slugs: parsedQuery.data.toolkitSlugs,
        user_ids: parsedQuery.data.userIds
      };
    }
    const result = await this.client.connectedAccounts.list(rawQuery);
    return transformConnectedAccountListResponse(result);
  }
  /**
   * Compound function to create a new connected account.
   * This function creates a new connected account and returns a connection request.
   * Users can then wait for the connection to be established using the `waitForConnection` method.
   *
   * @param {string} userId - User ID of the connected account
   * @param {string} authConfigId - Auth config ID of the connected account
   * @param {CreateConnectedAccountOptions} options - Options for creating a new connected account
   * @returns {Promise<ConnectionRequest>} Connection request object
   *
   * @example
   * ```typescript
   * // For OAuth2 authentication
   * const connectionRequest = await composio.connectedAccounts.initiate(
   *   'user_123',
   *   'auth_config_123',
   *   {
   *     callbackUrl: 'https://your-app.com/callback',
   *     config: AuthScheme.OAuth2({
   *       access_token: 'your_access_token',
   *       token_type: 'Bearer'
   *     })
   *   }
   * );
   *
   * // For API Key authentication
   * const connectionRequest = await composio.connectedAccounts.initiate(
   *   'user_123',
   *   'auth_config_123',
   *   {
   *     config: AuthScheme.ApiKey({
   *       api_key: 'your_api_key'
   *     })
   *   }
   * );
   *
   * // For Basic authentication
   * const connectionRequest = await composio.connectedAccounts.initiate(
   *   'user_123',
   *   'auth_config_123',
   *   {
   *     config: AuthScheme.Basic({
   *       username: 'your_username',
   *       password: 'your_password'
   *     })
   *   }
   * );
   * ```
   *
   * @link https://docs.composio.dev/reference/connected-accounts/create-connected-account
   */
  async initiate(userId, authConfigId, options) {
    const connectedAccount = await this.list({
      userIds: [userId],
      authConfigIds: [authConfigId]
    });
    if (connectedAccount.items.length > 0 && !options?.allowMultiple) {
      throw new ComposioMultipleConnectedAccountsError(
        `Multiple connected accounts found for user ${userId} in auth config ${authConfigId}. Please use the allowMultiple option to allow multiple connected accounts.`
      );
    } else if (connectedAccount.items.length > 0) {
      logger_default.warn(
        `[Warn:AllowMultiple] Multiple connected accounts found for user ${userId} in auth config ${authConfigId}`
      );
    }
    const state = options?.config ?? void 0;
    const response = await this.client.connectedAccounts.create({
      auth_config: {
        id: authConfigId
      },
      connection: {
        callback_url: options?.callbackUrl,
        user_id: userId,
        state
      }
      // @TODO: This is a temporary fix to allow api_key to be optional, in future ideally we should fix this from API side
    });
    const redirectUrl = typeof response.connectionData?.val?.redirectUrl === "string" ? response.connectionData.val.redirectUrl : null;
    return createConnectionRequest(
      this.client,
      response.id,
      response.connectionData.val.status,
      redirectUrl
    );
  }
  /**
   * Waits for a connection request to complete and become active.
   *
   * This method continuously polls the Composio API to check the status of a connection
   * until it either becomes active, enters a terminal error state, or times out.
   *
   * @param {string} connectedAccountId - The ID of the connected account to wait for
   * @param {number} [timeout=60000] - Maximum time to wait in milliseconds (default: 60 seconds)
   * @returns {Promise<ConnectedAccountRetrieveResponse>} The finalized connected account data
   * @throws {ComposioConnectedAccountNotFoundError} If the connected account cannot be found
   * @throws {ConnectionRequestFailedError} If the connection enters a failed, expired, or deleted state
   * @throws {ConnectionRequestTimeoutError} If the connection does not complete within the timeout period
   *
   * @example
   * ```typescript
   * // Wait for a connection to complete with default timeout
   * const connectedAccount = await composio.connectedAccounts.waitForConnection('conn_123abc');
   *
   * // Wait with a custom timeout of 2 minutes
   * const connectedAccount = await composio.connectedAccounts.waitForConnection('conn_123abc', 120000);
   * ```
   */
  async waitForConnection(connectedAccountId, timeout = 6e4) {
    const connectionRequest = createConnectionRequest(this.client, connectedAccountId);
    return connectionRequest.waitForConnection(timeout);
  }
  /**
   * Retrieves a specific connected account by its ID.
   *
   * This method fetches detailed information about a single connected account
   * and transforms the response to the SDK's standardized format.
   *
   * @param {string} nanoid - The unique identifier of the connected account
   * @returns {Promise<ConnectedAccountRetrieveResponse>} The connected account details
   * @throws {Error} If the connected account cannot be found or an API error occurs
   *
   * @example
   * ```typescript
   * // Get a connected account by ID
   * const account = await composio.connectedAccounts.get('conn_abc123');
   * console.log(account.status); // e.g., 'ACTIVE'
   * console.log(account.toolkit.slug); // e.g., 'github'
   * ```
   */
  async get(nanoid) {
    const response = await this.client.connectedAccounts.retrieve(nanoid);
    return transformConnectedAccountResponse(response);
  }
  /**
   * Deletes a connected account.
   *
   * This method permanently removes a connected account from the Composio platform.
   * This action cannot be undone and will revoke any access tokens associated with the account.
   *
   * @param {string} nanoid - The unique identifier of the connected account to delete
   * @returns {Promise<ConnectedAccountDeleteResponse>} The deletion response
   * @throws {Error} If the account doesn't exist or cannot be deleted
   *
   * @example
   * ```typescript
   * // Delete a connected account
   * await composio.connectedAccounts.delete('conn_abc123');
   * ```
   */
  async delete(nanoid) {
    return this.client.connectedAccounts.delete(nanoid);
  }
  /**
   * Refreshes a connected account's authentication credentials.
   *
   * This method attempts to refresh OAuth tokens or other credentials associated with
   * the connected account. This is useful when a token has expired or is about to expire.
   *
   * @param {string} nanoid - The unique identifier of the connected account to refresh
   * @returns {Promise<ConnectedAccountRefreshResponse>} The response containing the refreshed account details
   * @throws {Error} If the account doesn't exist or credentials cannot be refreshed
   *
   * @example
   * ```typescript
   * // Refresh a connected account's credentials
   * const refreshedAccount = await composio.connectedAccounts.refresh('conn_abc123');
   * ```
   */
  async refresh(nanoid) {
    return this.client.connectedAccounts.refresh(nanoid);
  }
  /**
   * Update the status of a connected account
   * @param {string} nanoid - Unique identifier of the connected account
   * @param {ConnectedAccountUpdateStatusParams} params - Parameters for updating the status
   * @returns {Promise<ConnectedAccountUpdateStatusResponse>} Updated connected account details
   *
   * @example
   * ```typescript
   * // Enable a connected account
   * const updatedAccount = await composio.connectedAccounts.updateStatus('conn_abc123', {
   *   enabled: true
   * });
   *
   * // Disable a connected account with a reason
   * const disabledAccount = await composio.connectedAccounts.updateStatus('conn_abc123', {
   *   enabled: false,
   *   reason: 'Token expired'
   * });
   * ```
   */
  async updateStatus(nanoid, params) {
    return this.client.connectedAccounts.updateStatus(nanoid, params);
  }
  /**
   * Enable a connected account
   * @param {string} nanoid - Unique identifier of the connected account
   * @returns {Promise<ConnectedAccountUpdateStatusResponse>} Updated connected account details
   *
   * @example
   * ```typescript
   * // Enable a previously disabled connected account
   * const enabledAccount = await composio.connectedAccounts.enable('conn_abc123');
   * console.log(enabledAccount.isDisabled); // false
   * ```
   */
  async enable(nanoid) {
    return this.client.connectedAccounts.updateStatus(nanoid, { enabled: true });
  }
  /**
   * Disable a connected account
   * @param {string} nanoid - Unique identifier of the connected account
   * @returns {Promise<ConnectedAccountUpdateStatusResponse>} Updated connected account details
   *
   * @example
   * ```typescript
   * // Disable a connected account
   * const disabledAccount = await composio.connectedAccounts.disable('conn_abc123');
   * console.log(disabledAccount.isDisabled); // true
   *
   * // You can also use updateStatus with a reason
   * // const disabledAccount = await composio.connectedAccounts.updateStatus('conn_abc123', {
   * //   enabled: false,
   * //   reason: 'No longer needed'
   * // });
   * ```
   */
  async disable(nanoid) {
    return this.client.connectedAccounts.updateStatus(nanoid, { enabled: false });
  }
};

// src/models/Toolkits.ts
var import_openai = require("openai");

// src/utils/transformers/toolkits.ts
var transformToolkitListResponse = (response) => {
  return transform(response).with(ToolKitListResponseSchema).using(
    (response2) => response2.items.map((item) => ({
      name: item.name,
      slug: item.slug,
      meta: {
        ...item.meta,
        categories: item.meta.categories?.map((category) => ({
          slug: category.id,
          name: category.name
        })),
        createdAt: item.meta.created_at,
        description: item.meta.description,
        logo: item.meta.logo,
        toolsCount: item.meta.tools_count,
        triggersCount: item.meta.triggers_count,
        updatedAt: item.meta.updated_at,
        appUrl: item.meta.app_url ?? void 0
      },
      isLocalToolkit: item.is_local_toolkit,
      authSchemes: item.auth_schemes,
      composioManagedAuthSchemes: item.composio_managed_auth_schemes,
      noAuth: item.no_auth
    }))
  );
};
var transformToolkitRetrieveResponse = (response) => {
  return transform(response).with(ToolkitRetrieveResponseSchema).using((response2) => ({
    name: response2.name,
    slug: response2.slug,
    meta: {
      ...response2.meta,
      createdAt: response2.meta.created_at,
      updatedAt: response2.meta.updated_at,
      toolsCount: response2.meta.tools_count,
      triggersCount: response2.meta.triggers_count,
      categories: response2.meta.categories?.map((category) => ({
        slug: category.slug,
        name: category.name
      }))
      // appUrl: response.meta.app_url, @TODO Update the client type to include this
    },
    isLocalToolkit: response2.is_local_toolkit,
    composioManagedAuthSchemes: response2.composio_managed_auth_schemes,
    authConfigDetails: response2.auth_config_details?.map((authConfig) => ({
      name: authConfig.name,
      mode: authConfig.mode,
      fields: {
        authConfigCreation: authConfig.fields.auth_config_creation,
        connectedAccountInitiation: authConfig.fields.connected_account_initiation
      },
      proxy: {
        baseUrl: authConfig.proxy?.base_url
      }
    })),
    baseUrl: response2.base_url,
    getCurrentUserEndpoint: response2.get_current_user_endpoint
  }));
};
var transformToolkitRetrieveCategoriesResponse = (response) => {
  return transform(response).with(ToolkitRetrieveCategoriesResponseSchema).using((response2) => ({
    items: response2.items.map((item) => ({
      id: item.id,
      name: item.name
    })),
    nextCursor: response2.next_cursor ?? null,
    totalPages: response2.total_pages
  }));
};

// src/models/Toolkits.ts
var Toolkits = class {
  client;
  constructor(client) {
    this.client = client;
    this.authorize = this.authorize.bind(this);
    telemetry.instrument(this);
  }
  /**
   * Retrieves a list of toolkits based on the provided query parameters.
   *
   * This method fetches toolkits from the Composio API and transforms the response
   * from snake_case to camelCase format for consistency with JavaScript/TypeScript conventions.
   *
   * @param {ToolkitListParams} query - The query parameters to filter toolkits
   * @returns {Promise<ToolKitListResponse>} The transformed list of toolkits
   *
   * @private
   */
  async getToolkits(query) {
    try {
      const parsedQuery = ToolkitsListParamsSchema.safeParse(query);
      if (!parsedQuery.success) {
        throw new ValidationError("Failed to parse toolkit list query", {
          cause: parsedQuery.error
        });
      }
      const result = await this.client.toolkits.list({
        category: parsedQuery.data.category,
        is_local: parsedQuery.data.isLocal,
        managed_by: parsedQuery.data.managedBy,
        sort_by: parsedQuery.data.sortBy
      });
      return transformToolkitListResponse(result);
    } catch (error) {
      throw new ComposioToolkitFetchError("Failed to fetch toolkits", {
        cause: error
      });
    }
  }
  /**
   * Retrieves a specific toolkit by its slug identifier.
   *
   * This method fetches a single toolkit from the Composio API and transforms
   * the response to use camelCase property naming consistent with JavaScript/TypeScript conventions.
   *
   * @param {string} slug - The unique slug identifier of the toolkit to retrieve
   * @returns {Promise<ToolkitRetrieveResponse>} The transformed toolkit object
   * @throws {ValidationError} If the response cannot be properly parsed
   * @throws {ComposioToolNotFoundError} If no toolkit with the given slug exists
   *
   * @private
   */
  async getToolkitBySlug(slug) {
    try {
      const result = await this.client.toolkits.retrieve(slug);
      return transformToolkitRetrieveResponse(result);
    } catch (error) {
      if (error instanceof import_openai.APIError && (error.status === 404 || error.status === 400)) {
        throw new ComposioToolkitNotFoundError(`Toolkit with slug ${slug} not found`, {
          meta: {
            slug
          },
          cause: error
        });
      }
      throw new ComposioToolkitFetchError(`Couldn't fetch Toolkit with slug: ${slug}`, {
        meta: {
          slug
        },
        cause: error
      });
    }
  }
  /**
   * Implementation method that handles both overloads for retrieving toolkits.
   *
   * @param {string | ToolkitListParams} arg - Either a toolkit slug or query parameters
   * @returns {Promise<ToolkitRetrieveResponse | ToolKitListResponse>} The toolkit or list of toolkits
   */
  async get(arg) {
    if (typeof arg === "string") {
      return this.getToolkitBySlug(arg);
    }
    return this.getToolkits(arg ?? {});
  }
  async getAuthConfigFields(toolkitSlug, authScheme, authConfigType, requiredOnly) {
    const toolkit = await this.getToolkitBySlug(toolkitSlug);
    if (!toolkit.authConfigDetails) {
      throw new ComposioAuthConfigNotFoundError("No auth config found for toolkit", {
        meta: {
          toolkitSlug
        }
      });
    }
    if (toolkit.authConfigDetails.length > 1 && !authScheme) {
      logger_default.warn(
        `Multiple auth configs found for ${toolkitSlug}, please specify the auth scheme to get details of specific auth scheme. Selecting the first scheme by default.`,
        {
          meta: {
            toolkitSlug
          }
        }
      );
    }
    const authConfig = authScheme ? toolkit.authConfigDetails.find((authConfig2) => authConfig2.mode === authScheme) : toolkit.authConfigDetails[0];
    if (!authConfig) {
      throw new ComposioAuthConfigNotFoundError(
        `Auth schema ${authScheme} not found for toolkit ${toolkitSlug} with auth scheme ${authScheme}`,
        {
          meta: {
            toolkitSlug,
            authScheme
          }
        }
      );
    }
    const requiredFields = authConfig.fields[authConfigType].required.map((field) => ({
      ...field,
      required: true
    }));
    if (requiredOnly) {
      return requiredFields;
    }
    const optionalFields = authConfig.fields[authConfigType].optional.map((field) => ({
      ...field,
      required: false
    }));
    return [...requiredFields, ...optionalFields];
  }
  /**
   * Retrieves the fields required for creating an auth config for a toolkit.
   * @param toolkitSlug - The slug of the toolkit to retrieve the fields for
   * @param authScheme - The auth scheme to retrieve the fields for
   * @param options.requiredOnly - Whether to only return the required fields
   * @returns {Promise<ToolkitAuthFieldsResponse>} The fields required for creating an auth config
   */
  async getAuthConfigCreationFields(toolkitSlug, authScheme, { requiredOnly = false } = {}) {
    return this.getAuthConfigFields(
      toolkitSlug,
      authScheme ?? null,
      "authConfigCreation",
      requiredOnly
    );
  }
  /**
   * Retrieves the fields required for initiating a connected account for a toolkit.
   * @param toolkitSlug - The slug of the toolkit to retrieve the fields for
   * @param authScheme - The auth scheme to retrieve the fields for
   * @param options.requiredOnly - Whether to only return the required fields
   * @returns {Promise<ToolkitAuthFieldsResponse>} The fields required for initiating a connected account
   */
  async getConnectedAccountInitiationFields(toolkitSlug, authScheme, { requiredOnly = false } = {}) {
    return this.getAuthConfigFields(
      toolkitSlug,
      authScheme ?? null,
      "connectedAccountInitiation",
      requiredOnly
    );
  }
  /**
   * Retrieves all toolkit categories available in the Composio SDK.
   *
   * This method fetches the complete list of categories from the Composio API
   * and transforms the response to use camelCase property naming.
   *
   * @returns {Promise<ToolkitRetrieveCategoriesResponse>} The list of toolkit categories
   *
   * @example
   * ```typescript
   * // Get all toolkit categories
   * const categories = await composio.toolkits.listCategories();
   * console.log(categories.items); // Array of category objects
   * ```
   */
  async listCategories() {
    const result = await this.client.toolkits.retrieveCategories();
    return transformToolkitRetrieveCategoriesResponse(result);
  }
  /**
   * Authorizes a user to use a toolkit.
   * This method will create an auth config if one doesn't exist and initiate a connection request.
   * @param {string} userId - The user id of the user to authorize
   * @param {string} toolkitSlug - The slug of the toolkit to authorize
   * @returns {Promise<ConnectionRequest>} The connection request object
   *
   * @example
   * ```typescript
   * const connectionRequest = await composio.toolkits.authorize(userId, 'github');
   * ```
   */
  async authorize(userId, toolkitSlug, authConfigId) {
    const toolkit = await this.getToolkitBySlug(toolkitSlug);
    const composioAuthConfig = new AuthConfigs(this.client);
    let authConfigIdToUse = authConfigId;
    if (!authConfigIdToUse) {
      const authConfig = await composioAuthConfig.list({
        toolkit: toolkitSlug
      });
      authConfigIdToUse = authConfig.items[0]?.id;
    }
    if (!authConfigIdToUse) {
      if (toolkit.authConfigDetails && toolkit.authConfigDetails.length > 0) {
        try {
          const authConfig = await composioAuthConfig.create(toolkitSlug, {
            type: "use_composio_managed_auth",
            name: `${toolkit.name} Auth Config`
          });
          authConfigIdToUse = authConfig.id;
        } catch (error) {
          if (error instanceof import_client4.default.APIError && error.status === 400) {
            throw new ComposioAuthConfigNotFoundError(
              `No Default auth config found for toolkit ${toolkitSlug}`,
              {
                meta: {
                  toolkitSlug
                },
                cause: error,
                possibleFixes: [
                  `Please Create an auth config for the toolkit ${toolkitSlug} via the dashboard`
                ]
              }
            );
          }
          throw error;
        }
      } else {
        throw new ComposioAuthConfigNotFoundError(
          `No auth configs found for toolkit ${toolkitSlug}`,
          {
            meta: {
              toolkitSlug
            }
          }
        );
      }
    }
    const composioConnectedAccount = new ConnectedAccounts(this.client);
    return await composioConnectedAccount.initiate(userId, authConfigIdToUse, {
      // in this magic function we allow multiple connected accounts per user for an auth config
      allowMultiple: true
    });
  }
};

// src/models/Triggers.ts
var import_client6 = require("@composio/client");

// src/types/triggers.types.ts
var import_zod8 = require("zod");
var TriggerStatuses = {
  ENABLE: "enable",
  DISABLE: "disable"
};
var TriggerStatusEnum = import_zod8.z.enum(["enable", "disable"]);
var TriggerSubscribeParamSchema = import_zod8.z.object({
  toolkits: import_zod8.z.array(import_zod8.z.string()).optional(),
  triggerId: import_zod8.z.string().optional(),
  connectedAccountId: import_zod8.z.string().optional(),
  authConfigId: import_zod8.z.string().optional(),
  triggerSlug: import_zod8.z.array(import_zod8.z.string()).optional(),
  triggerData: import_zod8.z.string().optional(),
  userId: import_zod8.z.string().optional()
});
var TriggerInstanceListActiveParamsSchema = import_zod8.z.object({
  authConfigIds: import_zod8.z.array(import_zod8.z.string()).nullable().optional(),
  connectedAccountIds: import_zod8.z.array(import_zod8.z.string()).nullable().optional(),
  limit: import_zod8.z.number().optional(),
  page: import_zod8.z.number().optional(),
  showDisabled: import_zod8.z.boolean().nullable().optional(),
  triggerIds: import_zod8.z.array(import_zod8.z.string()).nullable().optional(),
  triggerNames: import_zod8.z.array(import_zod8.z.string()).nullable().optional()
});
var TriggerInstanceListActiveResponseItemSchema = import_zod8.z.object({
  id: import_zod8.z.string(),
  connectedAccountId: import_zod8.z.string(),
  disabledAt: import_zod8.z.string().nullable(),
  state: import_zod8.z.record(import_zod8.z.unknown()),
  triggerConfig: import_zod8.z.record(import_zod8.z.unknown()),
  triggerName: import_zod8.z.string(),
  updatedAt: import_zod8.z.string(),
  triggerData: import_zod8.z.string().optional(),
  uuid: import_zod8.z.string().optional()
});
var TriggerInstanceListActiveResponseSchema = import_zod8.z.object({
  items: import_zod8.z.array(TriggerInstanceListActiveResponseItemSchema),
  nextCursor: import_zod8.z.string().nullable(),
  totalPages: import_zod8.z.number()
});
var TriggerInstanceUpsertParamsSchema = import_zod8.z.object({
  connectedAccountId: import_zod8.z.string().optional(),
  triggerConfig: import_zod8.z.record(import_zod8.z.unknown()).optional()
});
var TriggerInstanceUpsertResponseSchema = import_zod8.z.object({
  triggerId: import_zod8.z.string()
});
var TriggerInstanceManageUpdateParamsSchema = import_zod8.z.object({
  status: import_zod8.z.enum(["enable", "disable"])
});
var TriggerInstanceManageUpdateResponseSchema = import_zod8.z.object({
  status: import_zod8.z.enum(["success"])
});
var TriggerInstanceManageDeleteResponseSchema = import_zod8.z.object({
  triggerId: import_zod8.z.string()
});
var IncomingTriggerPayloadSchema = import_zod8.z.object({
  id: import_zod8.z.string().describe("The ID of the trigger"),
  uuid: import_zod8.z.string().describe("The UUID of the trigger"),
  triggerSlug: import_zod8.z.string().describe("The slug of the trigger that triggered the event"),
  toolkitSlug: import_zod8.z.string().describe("The slug of the toolkit that triggered the event"),
  userId: import_zod8.z.string().describe("The ID of the user that triggered the event"),
  payload: import_zod8.z.record(import_zod8.z.unknown()).describe("The payload of the trigger").optional(),
  originalPayload: import_zod8.z.record(import_zod8.z.unknown()).describe("The original payload of the trigger").optional(),
  metadata: import_zod8.z.object({
    id: import_zod8.z.string(),
    uuid: import_zod8.z.string(),
    toolkitSlug: import_zod8.z.string(),
    triggerSlug: import_zod8.z.string(),
    triggerData: import_zod8.z.string().optional(),
    triggerConfig: import_zod8.z.record(import_zod8.z.unknown()),
    connectedAccount: import_zod8.z.object({
      id: import_zod8.z.string(),
      uuid: import_zod8.z.string(),
      authConfigId: import_zod8.z.string(),
      authConfigUUID: import_zod8.z.string(),
      userId: import_zod8.z.string(),
      status: import_zod8.z.enum(["ACTIVE", "INACTIVE"])
    })
  })
});
var TriggersTypeListParamsSchema = import_zod8.z.object({
  cursor: import_zod8.z.string().optional(),
  limit: import_zod8.z.number().nullish(),
  toolkits: import_zod8.z.array(import_zod8.z.string()).nullish()
});
var TriggerTypeSchema = import_zod8.z.object({
  slug: import_zod8.z.string(),
  name: import_zod8.z.string(),
  description: import_zod8.z.string(),
  instructions: import_zod8.z.string().optional(),
  toolkit: import_zod8.z.object({
    logo: import_zod8.z.string(),
    slug: import_zod8.z.string(),
    name: import_zod8.z.string()
  }),
  payload: import_zod8.z.record(import_zod8.z.unknown()),
  config: import_zod8.z.record(import_zod8.z.unknown())
});
var TriggersTypeListResponseSchema = import_zod8.z.object({
  items: import_zod8.z.array(TriggerTypeSchema),
  nextCursor: import_zod8.z.string().nullish(),
  totalPages: import_zod8.z.number()
});

// src/services/internal/InternalService.types.ts
var import_zod9 = require("zod");
var SDKRealtimeCredentialsResponseSchema = import_zod9.z.object({
  projectId: import_zod9.z.string().describe("The project ID"),
  pusherKey: import_zod9.z.string().describe("The Pusher key"),
  pusherCluster: import_zod9.z.string().describe("The Pusher cluster")
});

// src/services/internal/InternalService.ts
var SDK_REALTIME_CREDENTIALS_ENDPOINT = "/api/v3/internal/sdk/realtime/credentials";
var InternalService = class {
  constructor(client) {
    this.client = client;
    this.client = client;
  }
  /**
   * Get the SDK realtime credentials
   * @returns {SDKRealtimeCredentialsResponse} The SDK realtime credentials
   */
  async getSDKRealtimeCredentials() {
    const response = await this.client.request({
      method: "get",
      path: SDK_REALTIME_CREDENTIALS_ENDPOINT
    });
    const parsedResponse = SDKRealtimeCredentialsResponseSchema.safeParse({
      pusherKey: response.pusher_key,
      projectId: response.project_id,
      pusherCluster: response.pusher_cluster
    });
    logger_default.debug(
      `[InternalService] SDK realtime credentials: ${JSON.stringify(parsedResponse, null, 2)}`
    );
    if (!parsedResponse.success) {
      throw new ValidationError(`Failed to parse SDK realtime credentials`, {
        cause: parsedResponse.error
      });
    }
    return parsedResponse.data;
  }
};

// src/errors/TriggerErrors.ts
var import_client5 = require("@composio/client");
var TriggerErrorCodes = {
  TRIGGER_FAILED_TO_GET_SDK_REALTIME_CREDENTIALS: "TRIGGER_FAILED_TO_GET_SDK_REALTIME_CREDENTIALS",
  TRIGGER_FAILED_TO_CREATE_PUSHER_CLIENT: "TRIGGER_FAILED_TO_CREATE_PUSHER_CLIENT",
  TRIGGER_FAILED_TO_SUBSCRIBE_TO_PUSHER_CHANNEL: "TRIGGER_FAILED_TO_SUBSCRIBE_TO_PUSHER_CHANNEL",
  TRIGGER_FAILED_TO_UNSUBSCRIBE_FROM_PUSHER_CHANNEL: "TRIGGER_FAILED_TO_UNSUBSCRIBE_FROM_PUSHER_CHANNEL",
  TRIGGER_TYPE_NOT_FOUND: "TRIGGER_TYPE_NOT_FOUND"
};
var ComposioFailedToGetSDKRealtimeCredentialsError = class extends import_client5.ComposioError {
  name = "ComposioFailedToGetSDKRealtimeCredentialsError";
  code = TriggerErrorCodes.TRIGGER_FAILED_TO_GET_SDK_REALTIME_CREDENTIALS;
  statusCode = 500;
  possibleFixes = ["Please contact support."];
  constructor(message, options) {
    super(message, options);
  }
};
var ComposioFailedToCreatePusherClientError = class extends import_client5.ComposioError {
  name = "ComposioFailedToCreatePusherClientError";
  code = TriggerErrorCodes.TRIGGER_FAILED_TO_CREATE_PUSHER_CLIENT;
  statusCode = 500;
  possibleFixes = ["Please contact support."];
  constructor(message, options) {
    super(message, options);
  }
};
var ComposioFailedToSubscribeToPusherChannelError = class extends import_client5.ComposioError {
  name = "ComposioFailedToSubscribeToPusherChannelError";
  code = TriggerErrorCodes.TRIGGER_FAILED_TO_SUBSCRIBE_TO_PUSHER_CHANNEL;
  statusCode = 500;
  possibleFixes = ["Please contact support."];
  constructor(message, options) {
    super(message, options);
  }
};
var ComposioTriggerTypeNotFoundError = class extends import_client5.ComposioError {
  name = "ComposioTriggerTypeNotFoundError";
  code = TriggerErrorCodes.TRIGGER_TYPE_NOT_FOUND;
  statusCode = 404;
  possibleFixes = ["Please contact support."];
  constructor(message = "Trigger type not found", options) {
    super(message, options);
  }
};

// src/services/pusher/Pusher.ts
var PusherService = class {
  // these values are set via the Apollo API `/internal/sdk/realtime/credentials` endpoint
  clientId;
  pusherKey;
  pusherCluster;
  pusherChannel;
  // these details are set via the client SDK
  pusherBaseURL;
  apiKey;
  pusherClient;
  composioClient;
  constructor(client) {
    this.composioClient = client;
    this.pusherBaseURL = client.baseURL;
    this.apiKey = client.apiKey ?? process.env.COMPOSIO_API_KEY ?? "";
    telemetry.instrument(this);
  }
  /**
   * Creates a Pusher client
   *
   * This method is called when the Pusher client is first used.
   * It will fetch the SDK realtime credentials from the Apollo API and create a Pusher client.
   */
  async getPusherClient() {
    if (!this.pusherClient) {
      const internalService = new InternalService(this.composioClient);
      let sdkRealtimeCredentials;
      try {
        sdkRealtimeCredentials = await internalService.getSDKRealtimeCredentials();
      } catch (error) {
        throw new ComposioFailedToGetSDKRealtimeCredentialsError(
          "Failed to get SDK realtime credentials",
          {
            cause: error
          }
        );
      }
      this.clientId = sdkRealtimeCredentials.projectId;
      this.pusherKey = sdkRealtimeCredentials.pusherKey;
      this.pusherCluster = sdkRealtimeCredentials.pusherCluster;
      this.pusherChannel = `private-${this.clientId}_triggers`;
      logger_default.debug(
        `[PusherService] Creating Pusher client for client ID: ${this.clientId} in cluster ${this.pusherCluster}`
      );
      try {
        const { default: Pusher } = await import("pusher-js");
        this.pusherClient = new Pusher(this.pusherKey, {
          cluster: this.pusherCluster,
          channelAuthorization: {
            endpoint: `${this.pusherBaseURL}/api/v3/internal/sdk/realtime/auth`,
            headers: {
              "x-api-key": this.apiKey
            },
            transport: "ajax"
          }
        });
      } catch (error) {
        throw new ComposioFailedToCreatePusherClientError("Failed to create Pusher client", {
          cause: error
        });
      }
    }
    return this.pusherClient;
  }
  /**
   * Binds a chunked event to a Pusher client
   *
   *
   * @param channel - The Pusher client to bind the event to
   * @param event - The event to bind to
   * @param callback - The function to call when the event is received
   */
  bindWithChunking(channel, event, callback) {
    try {
      channel.bind(event, callback);
      const events = {};
      channel.bind("chunked-" + event, (data) => {
        try {
          const typedData = data;
          if (!typedData || typeof typedData.id !== "string" || typeof typedData.index !== "number") {
            throw new Error("Invalid chunked trigger data format");
          }
          if (!events.hasOwnProperty(typedData.id)) {
            events[typedData.id] = { chunks: [], receivedFinal: false };
          }
          const ev = events[typedData.id];
          ev.chunks[typedData.index] = typedData.chunk;
          if (typedData.final) ev.receivedFinal = true;
          if (ev.receivedFinal && ev.chunks.length === Object.keys(ev.chunks).length) {
            try {
              const parsedData = JSON.parse(ev.chunks.join(""));
              callback(parsedData);
            } catch (parseError) {
              const errorMessage = parseError instanceof Error ? parseError.message : String(parseError);
              logger_default.error("Failed to parse chunked data:", errorMessage);
            } finally {
              delete events[typedData.id];
            }
          }
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          logger_default.error("Error processing chunked trigger data:", errorMessage);
          if (data && typeof data === "object" && "id" in data) {
            delete events[data.id];
          }
        }
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger_default.error("Failed to bind chunked events:", error);
      throw new Error(`Failed to bind chunked events: ${errorMessage}`);
    }
  }
  /**
   * Subscribes to pusher to receive events from the server
   *
   * This method is used to subscribe to a Pusher channel.
   * It will create a Pusher client if it doesn't exist.
   *
   * @param channelName - The name of the Pusher channel to subscribe to
   * @param event - The event to subscribe to
   * @param fn - The function to call when the event is received
   */
  async subscribe(fn) {
    try {
      logger_default.debug(`[PusherService] Subscribing to channel: ${this.pusherChannel}`);
      const pusherClient = await this.getPusherClient();
      const channel = await pusherClient.subscribe(this.pusherChannel);
      channel.bind("pusher:subscription_error", (data) => {
        const error = data.error ? String(data.error) : "Unknown subscription error";
        throw new ComposioFailedToSubscribeToPusherChannelError(
          `Trigger subscription error: ${error}`,
          {
            cause: error
          }
        );
      });
      const safeCallback = (data) => {
        try {
          fn(data);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          logger_default.error("\u274C Error in trigger callback:", errorMessage);
        }
      };
      this.bindWithChunking(channel, "trigger_to_client", safeCallback);
      logger_default.info(`\u2705 Subscribed to triggers. You should start receiving events now.`);
    } catch (error) {
      throw new ComposioFailedToSubscribeToPusherChannelError(
        "Failed to subscribe to Pusher channel",
        {
          cause: error
        }
      );
    }
  }
  /**
   * Unsubscribes from a Pusher channel
   *
   * This method is used to unsubscribe from a Pusher channel.
   * It will create a Pusher client if it doesn't exist.
   *
   * @param channelName - The name of the Pusher channel to unsubscribe from
   */
  async unsubscribe() {
    try {
      logger_default.debug(`[PusherService] Unsubscribing from channel: ${this.pusherChannel}`);
      const pusherClient = await this.getPusherClient();
      await pusherClient.unsubscribe(this.pusherChannel);
      logger_default.info(`\u2705 Unsubscribed from triggers.`);
    } catch (error) {
      throw new ComposioFailedToSubscribeToPusherChannelError(
        "Failed to unsubscribe from Pusher channel",
        {
          cause: error
        }
      );
    }
  }
};

// src/utils/transformers/triggers.ts
function transformIncomingTriggerPayload(response) {
  return transform(response).with(IncomingTriggerPayloadSchema).using((response2) => ({
    id: response2.metadata.nanoId,
    uuid: response2.metadata.id,
    triggerSlug: response2.metadata.triggerName,
    toolkitSlug: response2.appName,
    userId: response2.metadata.connection?.clientUniqueUserId,
    payload: response2.payload,
    originalPayload: response2.originalPayload,
    metadata: {
      id: response2.metadata.nanoId,
      uuid: response2.metadata.id,
      triggerConfig: response2.metadata.triggerConfig,
      triggerSlug: response2.metadata.triggerName,
      toolkitSlug: response2.appName,
      triggerData: response2.metadata.triggerData,
      connectedAccount: {
        id: response2.metadata.connection?.connectedAccountNanoId,
        uuid: response2.metadata.connection?.id,
        authConfigId: response2.metadata.connection?.authConfigNanoId,
        authConfigUUID: response2.metadata.connection?.integrationId,
        userId: response2.metadata.connection?.clientUniqueUserId,
        status: response2.metadata.connection?.status
      }
    }
  }));
}
function transformTriggerTypeRetrieveResponse(response) {
  return transform(response).with(TriggerTypeSchema).using((response2) => ({
    slug: response2.slug,
    name: response2.name,
    description: response2.description,
    instructions: response2.instructions,
    toolkit: {
      logo: response2.toolkit.logo,
      slug: response2.toolkit.slug,
      name: response2.toolkit.name
    },
    payload: response2.payload,
    config: response2.config
  }));
}
function transformTriggerTypeListResponse(response) {
  return transform(response).with(TriggersTypeListResponseSchema).using((response2) => ({
    items: response2.items,
    nextCursor: response2.next_cursor ?? null,
    totalPages: response2.total_pages
  }));
}
function transformTriggerInstanceListActiveItem(response) {
  return transform(response).with(TriggerInstanceListActiveResponseItemSchema).using((response2) => ({
    id: response2.id,
    connectedAccountId: response2.connected_account_id,
    disabledAt: response2.disabled_at,
    state: response2.state,
    triggerConfig: response2.trigger_config,
    triggerName: response2.trigger_name,
    updatedAt: response2.updated_at,
    triggerData: response2.trigger_data,
    uuid: response2.uuid
  }));
}
function transformTriggerInstanceListActiveResponse(response) {
  return transform(response).with(TriggerInstanceListActiveResponseSchema).using((response2) => ({
    items: response2.items.map((item) => transformTriggerInstanceListActiveItem(item)),
    nextCursor: response2.next_cursor ?? null,
    totalPages: response2.total_pages
  }));
}

// src/models/Triggers.ts
var Triggers = class {
  client;
  pusherService;
  constructor(client) {
    this.client = client;
    this.pusherService = new PusherService(client);
    telemetry.instrument(this);
  }
  /**
   * Fetch list of all the active triggers
   *
   * @param {TriggerInstanceListActiveParams} query - The query parameters to filter the trigger instances
   * @returns {Promise<TriggerInstanceListActiveResponse>} List of trigger instances
   *
   * @throws {ValidationError} If the parameters are invalid
   * @throws {Error} If the client is not authenticated
   *
   * @example
   * ```ts
   * const triggers = await triggers.listActive({
   *   authConfigIds: ['123'],
   *   connectedAccountIds: ['456'],
   * });
   * ```
   */
  async listActive(query) {
    const parsedParams = TriggerInstanceListActiveParamsSchema.safeParse(query ?? {});
    if (!parsedParams.success) {
      throw new ValidationError(`Invalid parameters passed to list triggers`, {
        cause: parsedParams.error
      });
    }
    const result = await this.client.triggerInstances.listActive(
      query ? {
        auth_config_ids: parsedParams.data.authConfigIds,
        connected_account_ids: parsedParams.data.connectedAccountIds,
        limit: parsedParams.data.limit,
        page: parsedParams.data.page,
        show_disabled: parsedParams.data.showDisabled,
        trigger_ids: parsedParams.data.triggerIds,
        trigger_names: parsedParams.data.triggerNames
      } : void 0
    );
    return transformTriggerInstanceListActiveResponse(result);
  }
  /**
   * Create a new trigger instance for a user
   * If the connected account id is not provided, the first connected account for the user and toolkit will be used
   *
   * @param {string} userId - The user id of the trigger instance
   * @param {string} slug - The slug of the trigger instance
   * @param {TriggerInstanceUpsertParams} body - The parameters to create the trigger instance
   * @returns {Promise<TriggerInstanceUpsertResponse>} The created trigger instance
   */
  async create(userId, slug, body) {
    const parsedBody = TriggerInstanceUpsertParamsSchema.safeParse(body ?? {});
    if (!parsedBody.success) {
      throw new ValidationError(`Invalid parameters passed to create trigger`, {
        cause: parsedBody.error
      });
    }
    let triggerType;
    let toolkitSlug;
    try {
      triggerType = await this.getType(slug);
      toolkitSlug = triggerType.toolkit.slug;
    } catch (error) {
      if (error instanceof import_client6.APIError && (error.status === 400 || error.status === 404)) {
        throw new ComposioTriggerTypeNotFoundError(`Trigger type ${slug} not found`, {
          cause: error,
          possibleFixes: [
            `Please check the trigger slug`,
            `Visit the toolkit page to see the available triggers`
          ]
        });
      } else {
        throw error;
      }
    }
    let connectedAccountId = body?.connectedAccountId;
    try {
      const { items: connectedAccounts } = await this.client.connectedAccounts.list({
        user_ids: [userId],
        toolkit_slugs: [toolkitSlug]
      });
      if (connectedAccounts.length === 0) {
        throw new ComposioConnectedAccountNotFoundError(
          `No connected account found for user ${userId} for toolkit ${toolkitSlug}`,
          {
            cause: new Error(`No connected account found for user ${userId}`),
            possibleFixes: [`Create a new connected account for user ${userId}`]
          }
        );
      }
      const accountExists = connectedAccounts.some((acc) => acc.id === connectedAccountId);
      if (connectedAccountId && !accountExists) {
        throw new ComposioConnectedAccountNotFoundError(
          `Connected account ID ${connectedAccountId} not found for user ${userId}`,
          {
            cause: new Error(
              `Connected account ID ${connectedAccountId} not found for user ${userId}`
            ),
            possibleFixes: [
              `Create a new connected account for user ${userId}`,
              `Verify the connected account ID`
            ]
          }
        );
      }
      if (!connectedAccountId) {
        connectedAccountId = connectedAccounts[0].id;
        logger_default.warn(
          `[Warn] Multiple connected accounts found for user ${userId}, using the first one. Pass connectedAccountId to select a specific account.`
        );
      }
    } catch (error) {
      if (error instanceof import_client6.APIError && [400, 404].includes(error.status)) {
        throw new ComposioConnectedAccountNotFoundError(
          `No connected account found for user ${userId} for toolkit ${toolkitSlug}`,
          {
            cause: error,
            possibleFixes: [`Create a new connected account for user ${userId}`]
          }
        );
      }
      throw error;
    }
    const result = await this.client.triggerInstances.upsert(slug, {
      connected_account_id: connectedAccountId,
      trigger_config: parsedBody.data.triggerConfig
    });
    return {
      triggerId: result.trigger_id
    };
  }
  /**
   * Update an existing trigger instance
   *
   * @param {string} triggerId - The Id of the trigger instance
   * @param {TriggerInstanceManageUpdateParams} body - The parameters to update the trigger instance
   * @returns {Promise<TriggerInstanceManageUpdateResponse>} The updated trigger instance response
   */
  async update(triggerId, body) {
    return this.client.triggerInstances.manage.update(triggerId, body);
  }
  /**
   * Delete a trigger instance
   *
   * @param {string} triggerId - The slug of the trigger instance
   * @returns
   */
  async delete(triggerId) {
    const result = await this.client.triggerInstances.manage.delete(triggerId);
    return {
      triggerId: result.trigger_id
    };
  }
  /**
   * Disable a trigger instance
   *
   * @param {string} triggerId - The id of the trigger instance
   * @returns {Promise<TriggerInstanceUpsertResponse>} The updated trigger instance
   */
  async disable(triggerId) {
    return this.client.triggerInstances.manage.update(triggerId, {
      status: "disable"
    });
  }
  /**
   * Enable a trigger instance
   *
   * @param {string} triggerId - The id of the trigger instance
   * @returns {Promise<TriggerInstanceUpsertResponse>} The updated trigger instance
   */
  async enable(triggerId) {
    return this.client.triggerInstances.manage.update(triggerId, {
      status: "enable"
    });
  }
  /**
   * @TODO Learn about trigger types
   */
  /**
   * List all the trigger types
   *
   * @param {TriggersTypeListParams} query - The query parameters to filter the trigger types
   * @param {RequestOptions} options - Request options
   * @returns {Promise<TriggersTypeListResponse>} The list of trigger types
   */
  async listTypes(query) {
    const parsedQuery = transform(query ?? {}).with(TriggersTypeListParamsSchema).using((raw) => raw);
    const result = await this.client.triggersTypes.list({
      cursor: parsedQuery.cursor,
      limit: parsedQuery.limit,
      toolkit_slugs: parsedQuery.toolkits
    });
    return transformTriggerTypeListResponse(result);
  }
  /**
   * Retrieve a trigger type by its slug
   *
   * @param {string} slug - The slug of the trigger type
   * @param {RequestOptions} options - request options
   * @returns {Promise<TriggersTypeRetrieveResponse>} The trigger type object
   */
  async getType(slug) {
    const result = await this.client.triggersTypes.retrieve(slug);
    return transformTriggerTypeRetrieveResponse(result);
  }
  /**
   * Fetches the list of all the available trigger enums
   *
   * This method is used by the CLI where filters are not required.
   * @param options
   * @returns
   */
  async listEnum() {
    return this.client.triggersTypes.retrieveEnum();
  }
  /**
   * Applies compound filters to the trigger data
   * @param data data to apply filters to
   * @returns True if the trigger data matches the filters, false otherwise
   */
  shouldSendTriggerAfterFilters(filters, data) {
    if (filters.toolkits?.length && !filters.toolkits.map((toolkit) => toolkit.toLowerCase()).includes(data.toolkitSlug.toLowerCase())) {
      logger_default.debug(
        "Trigger does not match toolkits filter",
        JSON.stringify(filters.toolkits, null, 2)
      );
      return false;
    }
    if (filters.triggerId && filters.triggerId !== data.id) {
      logger_default.debug(
        "Trigger does not match triggerId filter",
        JSON.stringify(filters.triggerId, null, 2)
      );
      return false;
    }
    if (filters.connectedAccountId && filters.connectedAccountId !== data.metadata.connectedAccount.id) {
      logger_default.debug(
        "Trigger does not match connectedAccountId filter",
        JSON.stringify(filters.connectedAccountId, null, 2)
      );
      return false;
    }
    if (filters.triggerSlug?.length && !filters.triggerSlug.map((triggerSlug) => triggerSlug.toLowerCase()).includes(data.triggerSlug.toLowerCase())) {
      logger_default.debug(
        "Trigger does not match triggerSlug filter",
        JSON.stringify(filters.triggerSlug, null, 2)
      );
      return false;
    }
    if (filters.triggerData && filters.triggerData !== data.metadata.triggerData) {
      logger_default.debug(
        "Trigger does not match triggerData filter",
        JSON.stringify(filters.triggerData, null, 2)
      );
      return false;
    }
    if (filters.userId && filters.userId !== data.metadata.connectedAccount.userId) {
      logger_default.debug("Trigger does not match userId filter", JSON.stringify(filters.userId, null, 2));
      return false;
    }
    logger_default.debug("Trigger matches all filters", JSON.stringify(filters, null, 2));
    return true;
  }
  /**
   * Subscribe to all the triggers
   *
   * @param fn - The function to call when a trigger is received
   * @param filters - The filters to apply to the triggers
   *
   * @example
   * ```ts
   *
   * triggers.subscribe((data) => {
   *   console.log(data);
   * }, );
   * ```
   */
  async subscribe(fn, filters = {}) {
    if (!fn) throw new Error("Function is required for trigger subscription");
    const parsedFilters = TriggerSubscribeParamSchema.safeParse(filters);
    if (!parsedFilters.success) {
      throw new ValidationError(`Invalid parameters passed to subscribe to triggers`, {
        cause: parsedFilters.error
      });
    }
    logger_default.debug("\u{1F504} Subscribing to triggers with filters: ", JSON.stringify(filters, null, 2));
    await this.pusherService.subscribe((_data) => {
      logger_default.debug("Received raw trigger data", JSON.stringify(_data, null, 2));
      const data = _data;
      const parsedData = transformIncomingTriggerPayload(data);
      if (this.shouldSendTriggerAfterFilters(parsedFilters.data, parsedData)) {
        try {
          fn(parsedData);
        } catch (error) {
          logger_default.error("\u274C Error in trigger callback:", error);
        }
      } else {
        logger_default.debug("Trigger does not match filters", JSON.stringify(parsedFilters.data, null, 2));
      }
    });
  }
  /**
   * Unsubscribe from all the triggers
   *
   * @returns {Promise<void>}
   *
   * @example
   * ```ts
   * composio.trigger.subscribe((data) => {
   *   console.log(data);
   * });
   *
   * await triggers.unsubscribe();
   * ```
   */
  async unsubscribe() {
    await this.pusherService.unsubscribe();
  }
};

// src/types/mcp.types.ts
var import_zod10 = require("zod");
var MCPToolkitConfigSchema = import_zod10.z.object({
  toolkit: import_zod10.z.string().min(1, "Toolkit name cannot be empty"),
  authConfigId: import_zod10.z.string().min(1, "Auth config ID cannot be empty"),
  allowedTools: import_zod10.z.array(import_zod10.z.string().min(1, "Tool name cannot be empty")).min(1, "At least one tool must be specified")
});
var MCPToolkitConfigsArraySchema = import_zod10.z.array(MCPToolkitConfigSchema).min(1, "At least one toolkit configuration is required").refine((configs) => {
  const toolkits = configs.map((config) => config.toolkit);
  const uniqueToolkits = new Set(toolkits);
  return uniqueToolkits.size === toolkits.length;
}, "Duplicate toolkits are not allowed. Each toolkit must be unique.");
var MCPAuthOptionsSchema = import_zod10.z.object({
  isChatAuth: import_zod10.z.boolean().optional()
});
var MCPGetServerParamsSchema = import_zod10.z.object({
  userId: import_zod10.z.string().min(1, "User ID cannot be empty").optional(),
  connectedAccountIds: import_zod10.z.record(import_zod10.z.string(), import_zod10.z.string().min(1, "Account ID cannot be empty")).optional()
}).refine(
  (data) => {
    const hasUserId = !!data.userId;
    const hasConnectedAccountIds = !!data.connectedAccountIds && Object.keys(data.connectedAccountIds).length > 0;
    return hasUserId !== hasConnectedAccountIds;
  },
  {
    message: "Must provide either userId or connectedAccountIds, but not both"
  }
);
var MCPGenerateURLParamsSchema = import_zod10.z.object({
  userIds: import_zod10.z.array(import_zod10.z.string()).optional(),
  connectedAccountIds: import_zod10.z.array(import_zod10.z.string()).optional(),
  isChatAuth: import_zod10.z.boolean().optional()
});
var ComposioGenerateURLParamsSchema = import_zod10.z.object({
  user_ids: import_zod10.z.array(import_zod10.z.string()).optional(),
  connected_account_ids: import_zod10.z.array(import_zod10.z.string()).optional(),
  mcp_server_id: import_zod10.z.string(),
  managed_auth_by_composio: import_zod10.z.boolean().optional()
});
var GenerateURLParamsSchema = import_zod10.z.object({
  userIds: import_zod10.z.array(import_zod10.z.string()).optional(),
  connectedAccountIds: import_zod10.z.array(import_zod10.z.string()).optional(),
  mcpServerId: import_zod10.z.string(),
  composioManagedAuth: import_zod10.z.boolean().optional()
});
var GenerateURLResponseSchema = import_zod10.z.object({
  connectedAccountUrls: import_zod10.z.array(import_zod10.z.string()).optional(),
  userIdsUrl: import_zod10.z.array(import_zod10.z.string()).optional(),
  mcpUrl: import_zod10.z.string().min(1, "MCP URL cannot be empty")
});
var ComposioGenerateURLResponseSchema = import_zod10.z.object({
  connected_account_urls: import_zod10.z.array(import_zod10.z.string()).optional(),
  user_ids_url: import_zod10.z.array(import_zod10.z.string()).optional(),
  mcp_url: import_zod10.z.string().min(1, "MCP URL cannot be empty")
});
var MCPSingleAppServerSchema = import_zod10.z.object({
  name: import_zod10.z.string().describe("Name of the MCP server"),
  tools: import_zod10.z.array(import_zod10.z.string()).describe("List of allowed tools"),
  authConfigId: import_zod10.z.string().optional().describe("Auth config ID for the server")
});
var MCPMultiAppServerSchema = import_zod10.z.object({
  name: import_zod10.z.string().describe("Name of the MCP server"),
  tools: import_zod10.z.array(import_zod10.z.string()).describe("List of allowed tools across toolkits"),
  toolkits: import_zod10.z.array(import_zod10.z.string()).describe("List of allowed toolkits")
});
var MCPServerSchema = import_zod10.z.object({
  id: import_zod10.z.string().describe("Unique identifier for the MCP server"),
  type: import_zod10.z.enum(["single", "multi"]).describe("Type of MCP server"),
  createdAt: import_zod10.z.string().describe("Creation timestamp"),
  updatedAt: import_zod10.z.string().describe("Last update timestamp"),
  status: import_zod10.z.enum(["active", "inactive", "error"]).default("active"),
  config: import_zod10.z.union([MCPSingleAppServerSchema, MCPMultiAppServerSchema])
});
var MCPServerListResponseSchema = import_zod10.z.object({
  items: import_zod10.z.array(MCPServerSchema),
  total: import_zod10.z.number(),
  page: import_zod10.z.number(),
  pageSize: import_zod10.z.number()
});
var MCPServerUpdateParamsSchema = import_zod10.z.object({
  name: import_zod10.z.string().optional().describe("New name for the server"),
  toolkits: import_zod10.z.array(import_zod10.z.string()).optional().describe("Updated list of toolkits"),
  allowedTools: import_zod10.z.array(import_zod10.z.string()).optional().describe("Updated list of allowed tools")
});
var MCPServerCreateResponseSchema = MCPServerSchema;
var ConnectionStatus = /* @__PURE__ */ ((ConnectionStatus2) => {
  ConnectionStatus2["CONNECTED"] = "CONNECTED";
  ConnectionStatus2["DISCONNECTED"] = "DISCONNECTED";
  return ConnectionStatus2;
})(ConnectionStatus || {});
var CustomCreateResponseSchema = import_zod10.z.object({
  id: import_zod10.z.string().min(1, "Server ID cannot be empty"),
  name: import_zod10.z.string().min(1, "Server name cannot be empty"),
  createdAt: import_zod10.z.string().nullish(),
  updatedAt: import_zod10.z.string().nullish(),
  status: import_zod10.z.string().nullish()
});
var ComposioCustomCreateResponseSchema = import_zod10.z.object({
  id: import_zod10.z.string().min(1, "Server ID cannot be empty"),
  name: import_zod10.z.string().min(1, "Server name cannot be empty"),
  created_at: import_zod10.z.string().nullish(),
  updated_at: import_zod10.z.string().nullish(),
  status: import_zod10.z.string().nullish()
});
var McpListResponseSchema = import_zod10.z.object({
  items: import_zod10.z.array(
    import_zod10.z.object({
      id: import_zod10.z.string().min(1, "Server ID cannot be empty"),
      name: import_zod10.z.string().min(1, "Server name cannot be empty"),
      createdAt: import_zod10.z.string().optional(),
      updatedAt: import_zod10.z.string().optional(),
      status: import_zod10.z.string().optional()
    })
  ).optional()
});
var ComposioMcpListResponseSchema = import_zod10.z.object({
  items: import_zod10.z.array(
    import_zod10.z.object({
      id: import_zod10.z.string().min(1, "Server ID cannot be empty"),
      name: import_zod10.z.string().min(1, "Server name cannot be empty"),
      created_at: import_zod10.z.string().optional(),
      updated_at: import_zod10.z.string().optional(),
      status: import_zod10.z.string().optional()
    })
  ).optional()
});
var McpRetrieveResponseSchema = import_zod10.z.object({
  id: import_zod10.z.string().min(1, "Server ID cannot be empty"),
  name: import_zod10.z.string().min(1, "Server name cannot be empty"),
  createdAt: import_zod10.z.string().optional(),
  updatedAt: import_zod10.z.string().optional(),
  status: import_zod10.z.string().optional(),
  toolkits: import_zod10.z.array(import_zod10.z.string()).optional(),
  tools: import_zod10.z.array(import_zod10.z.string()).optional(),
  managedAuthViaComposio: import_zod10.z.boolean().optional(),
  authConfigIds: import_zod10.z.array(import_zod10.z.string()).optional(),
  mcpUrl: import_zod10.z.string(),
  commands: import_zod10.z.object({
    claude: import_zod10.z.string(),
    cursor: import_zod10.z.string(),
    windsurf: import_zod10.z.string()
  })
});
var ComposioMcpRetrieveResponseSchema = import_zod10.z.object({
  id: import_zod10.z.string().min(1, "Server ID cannot be empty"),
  name: import_zod10.z.string().min(1, "Server name cannot be empty"),
  created_at: import_zod10.z.string().optional(),
  updated_at: import_zod10.z.string().optional(),
  status: import_zod10.z.string().optional(),
  toolkits: import_zod10.z.array(import_zod10.z.string()).optional(),
  tools: import_zod10.z.array(import_zod10.z.string()).optional(),
  managed_auth_via_composio: import_zod10.z.boolean().optional()
});
var McpDeleteResponseSchema = import_zod10.z.object({
  id: import_zod10.z.string().min(1, "Server ID cannot be empty"),
  deleted: import_zod10.z.boolean().optional(),
  message: import_zod10.z.string().optional()
});
var ComposioMcpDeleteResponseSchema = import_zod10.z.object({
  id: import_zod10.z.string().min(1, "Server ID cannot be empty"),
  deleted: import_zod10.z.boolean().optional(),
  message: import_zod10.z.string().optional()
});
var McpUpdateResponseSchema = import_zod10.z.object({
  id: import_zod10.z.string().min(1, "Server ID cannot be empty"),
  name: import_zod10.z.string().min(1, "Server name cannot be empty"),
  createdAt: import_zod10.z.string().optional(),
  updatedAt: import_zod10.z.string().optional(),
  status: import_zod10.z.string().optional(),
  toolkits: import_zod10.z.array(import_zod10.z.string()).optional(),
  tools: import_zod10.z.array(import_zod10.z.string()).optional()
});
var ComposioMcpUpdateResponseSchema = import_zod10.z.object({
  id: import_zod10.z.string().min(1, "Server ID cannot be empty"),
  name: import_zod10.z.string().min(1, "Server name cannot be empty"),
  created_at: import_zod10.z.string().optional(),
  updated_at: import_zod10.z.string().optional(),
  status: import_zod10.z.string().optional(),
  toolkits: import_zod10.z.array(import_zod10.z.string()).optional(),
  tools: import_zod10.z.array(import_zod10.z.string()).optional()
});

// src/utils/transformers/mcp.ts
function transformMcpCreateResponse(response) {
  const result = CustomCreateResponseSchema.safeParse({
    id: response.id,
    name: response.name,
    createdAt: response.created_at,
    updatedAt: response.updated_at,
    status: response.status
  });
  if (!result.success) {
    throw new ValidationError("Failed to parse MCP create response", {
      cause: result.error
    });
  }
  return result.data;
}
function transformMcpListResponse(response) {
  const transformedItems = response.items?.map((item) => ({
    id: item.id,
    name: item.name,
    createdAt: item.created_at,
    updatedAt: item.updated_at,
    status: item.status
  }));
  const result = McpListResponseSchema.safeParse({
    items: transformedItems
  });
  if (!result.success) {
    throw new ValidationError("Failed to parse MCP list response", {
      cause: result.error
    });
  }
  return result.data;
}
function transformMcpRetrieveResponse(response) {
  const result = McpRetrieveResponseSchema.safeParse({
    id: response.id,
    name: response.name,
    createdAt: response.created_at,
    updatedAt: response.updated_at,
    status: response.status,
    toolkits: response.toolkits,
    tools: response.allowed_tools,
    managedAuthViaComposio: response.managed_auth_via_composio,
    authConfigIds: response.auth_config_ids,
    mcpUrl: response.mcp_url,
    commands: response.commands
  });
  if (!result.success) {
    throw new ValidationError("Failed to parse MCP retrieve response", {
      cause: result.error
    });
  }
  return result.data;
}
function transformMcpDeleteResponse(response) {
  const result = McpDeleteResponseSchema.safeParse({
    id: response.id,
    deleted: response.deleted,
    message: response.message
  });
  if (!result.success) {
    throw new ValidationError("Failed to parse MCP delete response", {
      cause: result.error
    });
  }
  return result.data;
}
function transformMcpUpdateResponse(response) {
  const result = McpUpdateResponseSchema.safeParse({
    id: response.id,
    name: response.name,
    createdAt: response.created_at,
    updatedAt: response.updated_at,
    status: response.status,
    toolkits: response.toolkits,
    tools: response.tools
  });
  if (!result.success) {
    throw new ValidationError("Failed to parse MCP update response", {
      cause: result.error
    });
  }
  return result.data;
}
function transformMcpGenerateUrlResponse(response) {
  const result = GenerateURLResponseSchema.safeParse({
    connectedAccountUrls: response.connected_account_urls,
    userIdsUrl: response.user_ids_url,
    mcpUrl: response.mcp_url
  });
  if (!result.success) {
    throw new ValidationError("Failed to parse MCP generate URL response", {
      cause: result.error
    });
  }
  return result.data;
}

// src/models/MCP.ts
var MCP = class {
  client;
  provider;
  toolkits;
  constructor(client, provider) {
    this.client = client;
    this.provider = provider;
    this.toolkits = new Toolkits(client);
    telemetry.instrument(this);
  }
  /**
   * Validates toolkit configurations using Zod schema
   * @private
   * @param {MCPToolkitConfig[]} toolkitConfigs - Array of toolkit configurations to validate
   * @param {MCPAuthOptions} [authOptions] - Authentication options to validate
   * @throws {ValidationError} If validation fails
   */
  validateInputs(toolkitConfigs, authOptions) {
    const toolkitConfigsResult = MCPToolkitConfigsArraySchema.safeParse(toolkitConfigs);
    if (toolkitConfigsResult.error) {
      throw new ValidationError("Failed to parse toolkit configurations", {
        cause: toolkitConfigsResult.error
      });
    }
    if (authOptions !== void 0) {
      const authOptionsResult = MCPAuthOptionsSchema.safeParse(authOptions);
      if (authOptionsResult.error) {
        throw new ValidationError("Failed to parse auth options", {
          cause: authOptionsResult.error
        });
      }
    }
  }
  /**
   * Create a new MCP server
   * @param {Object} params - Parameters for creating the MCP server
   * @param {Array} params.authConfig - Array of auth configurations with id and allowed tools
   * @param {Object} params.options - Server creation options
   * @param {string} params.options.name - Unique name for the MCP server
   * @param {boolean} [params.options.isChatAuth] - Whether to use chat-based authentication
   * @returns {Promise<McpServerCreateResponse<T>>} Created server details with instance getter
   *
   * @example
   * ```typescript
   * const server = await composio.mcp.create("personal-mcp-server", [
   *     {
   *       authConfigId: "ac_xyz",
   *       allowedTools: ["GMAIL_FETCH_EMAILS", "SLACK_SEND_MESSAGE"]
   *     }
   *   ],
   *   {
   *     isChatAuth: true
   *   }
   * });
   *
   * // Use convenience method on response
   * const urls = await server.getServer({
   *   userId: "user123"
   * });
   * ```
   */
  async create(name, serverConfig, options) {
    if (!serverConfig || serverConfig.length === 0) {
      throw new ValidationError("At least one auth config is required", {});
    }
    if (!name) {
      throw new ValidationError("Server name is required", {});
    }
    try {
      const mcpServer = await this.getByName(name);
      const authConfigs = mcpServer.authConfigIds?.sort();
      const sortedCurrentAuthConfigs = serverConfig.map((config) => config.authConfigId).sort();
      if (authConfigs.length > 0 && !authConfigs.every((config, index) => config === sortedCurrentAuthConfigs[index])) {
        throw new ValidationError(
          "MCP server with this name already exists with different auth configs",
          {
            meta: { serverName: name }
          }
        );
      }
      const tools = mcpServer.tools?.sort();
      const sortedCurrentTools = serverConfig.flatMap((config) => config.allowedTools).sort();
      console.log(tools, sortedCurrentTools, "tools");
      if (tools?.length > 0 && !tools.every((tool, index) => tool === sortedCurrentTools[index])) {
        throw new ValidationError("MCP server with this name already exists with different tools", {
          meta: { serverName: name }
        });
      }
      const authConfigDetails2 = await Promise.all(
        serverConfig.map((config) => this.client.authConfigs.retrieve(config.authConfigId))
      );
      const toolkits2 = authConfigDetails2.map((config) => config.toolkit.slug);
      const camelCaseResponse2 = transformMcpCreateResponse({
        id: mcpServer.id,
        name: mcpServer.name,
        auth_config_ids: serverConfig.map((config) => config.authConfigId),
        allowed_tools: serverConfig.flatMap((config) => config.allowedTools),
        managed_auth_via_composio: options.isChatAuth || false,
        commands: mcpServer.commands,
        created_at: mcpServer.createdAt,
        updated_at: mcpServer.updatedAt,
        mcp_url: mcpServer.mcpUrl
      });
      return {
        ...camelCaseResponse2,
        toolkits: toolkits2,
        getServer: async (params) => {
          return this.getServer(camelCaseResponse2.id, params.userId || "", {
            isChatAuth: options.isChatAuth
          });
        }
      };
    } catch (error) {
      if (error instanceof ValidationError && !error.message.includes("not found")) {
        throw error;
      }
    }
    const authConfigDetails = await Promise.all(
      serverConfig.map((config) => this.client.authConfigs.retrieve(config.authConfigId))
    );
    const toolkits = authConfigDetails.map((config) => config.toolkit.slug);
    let mcpServerCreatedResponse;
    try {
      mcpServerCreatedResponse = await this.client.mcp.custom.create({
        name,
        toolkits,
        custom_tools: serverConfig.flatMap((config) => config.allowedTools),
        managed_auth_via_composio: options.isChatAuth || false,
        auth_config_ids: serverConfig.map((config) => config.authConfigId)
      });
    } catch (error) {
      throw new ValidationError("Failed to create MCP server", {
        cause: error
      });
    }
    const serverResponseResult = ComposioCustomCreateResponseSchema.safeParse(mcpServerCreatedResponse);
    if (serverResponseResult.error) {
      throw new ValidationError("Failed to parse MCP server creation response", {
        cause: serverResponseResult.error
      });
    }
    const camelCaseResponse = transformMcpCreateResponse(mcpServerCreatedResponse);
    return {
      ...camelCaseResponse,
      toolkits,
      getServer: async (params) => {
        return this.getServer(camelCaseResponse.id, params.userId || "", {
          isChatAuth: options.isChatAuth
        });
      }
    };
  }
  /**
   * Get the connection status of a user for an MCP server
   *
   * Checks whether a user has the necessary connected accounts to use all toolkits
   * configured in the specified MCP server. Returns both overall connection status
   * and individual status for each toolkit.
   *
   * @param {Object} params - Parameters for checking connection status
   * @param {string} params.id - The UUID of the MCP server to check
   * @param {string} params.userId - The ID of the user to check connection status for
   * @returns {Promise<McpUserConnectionStatus>} Complete connection status including:
   *   - `type`: Overall status (CONNECTED if all toolkits are connected, DISCONNECTED otherwise)
   *   - `connected`: Boolean indicating if user can use the MCP server
   *   - `connectedToolkits`: Record mapping each toolkit name to its individual connection status
   *
   * @throws {ValidationError} When MCP server has no toolkits configured
   * @throws {ValidationError} When MCP server retrieval fails
   *
   * @example
   * ```typescript
   * // Check if user can access an MCP server with Gmail and Slack toolkits
   * const connectionStatus = await composio.mcp.getUserConnectionStatus('user123', 'mcp-server-uuid');
   *
   * if (connectionStatus.connected) {
   *   console.log('User can access all required toolkits');
   *   // connectionStatus.type === ConnectionStatus.CONNECTED
   * } else {
   *   console.log('User is missing some toolkit connections');
   *   // Check individual toolkit statuses
   *   Object.entries(connectionStatus.connectedToolkits).forEach(([toolkit, status]) => {
   *     if (!status.connected) {
   *       console.log(`Missing connection for toolkit: ${toolkit}`);
   *     }
   *   });
   * }
   * ```
   *
   * @example
   * ```typescript
   * // Example response when user has Gmail connected but missing Slack
   * {
   *   type: ConnectionStatus.DISCONNECTED,
   *   connected: false,
   *   connectedToolkits: {
   *     GMAIL: {
   *       type: ConnectionStatus.CONNECTED,
   *       connected: true,
   *       toolkit: 'GMAIL',
   *       connectedAccountId: 'conn_gmail_123'
   *     },
   *     SLACK: {
   *       type: ConnectionStatus.DISCONNECTED,
   *       connected: false,
   *       toolkit: 'SLACK'
   *     }
   *   }
   * }
   * ```
   */
  async getUserConnectionStatus(userId, serverId) {
    const serverDetails = await this.get(serverId);
    if (!serverDetails.toolkits || serverDetails.toolkits.length === 0) {
      throw new ValidationError("MCP server has no toolkits configured", {
        meta: { serverId }
      });
    }
    const connectedAccounts = await this.client.connectedAccounts.list({
      user_ids: [userId],
      toolkit_slugs: serverDetails.toolkits.map((toolkit) => toolkit.toLowerCase()),
      statuses: ["ACTIVE"]
    });
    const connectedAccountsByToolkit = /* @__PURE__ */ new Map();
    connectedAccounts.items?.forEach((account) => {
      connectedAccountsByToolkit.set(account.toolkit.slug.toLowerCase(), account.id);
    });
    const connectedToolkits = {};
    let allToolkitsConnected = true;
    for (const toolkit of serverDetails.toolkits) {
      const connectedAccountId = connectedAccountsByToolkit.get(toolkit.toLowerCase());
      if (connectedAccountId) {
        connectedToolkits[toolkit] = {
          type: "CONNECTED" /* CONNECTED */,
          connected: true,
          toolkit,
          connectedAccountId
        };
      } else {
        connectedToolkits[toolkit] = {
          type: "DISCONNECTED" /* DISCONNECTED */,
          connected: false,
          toolkit
        };
        allToolkitsConnected = false;
      }
    }
    if (allToolkitsConnected) {
      return {
        type: "CONNECTED" /* CONNECTED */,
        connected: true,
        connectedToolkits
      };
    } else {
      return {
        type: "DISCONNECTED" /* DISCONNECTED */,
        connected: false,
        connectedToolkits
      };
    }
  }
  /**
   * Get the connection parameters for a toolkit
   * @param {string} serverId - The UUID of the MCP server
   * @param {string} toolkit - The toolkit to get connection parameters for
   * @returns {Promise<ToolkitAuthFieldsResponse>} Connection parameters for the toolkit
   */
  async getConnectionParams(serverId, toolkit) {
    const mcpServerDetails = await this.get(serverId);
    const authConfigs = mcpServerDetails.authConfigIds ? await Promise.all(
      mcpServerDetails.authConfigIds.map((id) => this.client.authConfigs.retrieve(id))
    ) : [];
    const authConfig = authConfigs.find((config) => config.toolkit.slug === toolkit);
    if (!authConfig) {
      throw new ValidationError("Auth config not found", {
        meta: { serverId, toolkit }
      });
    }
    const connectionParams = await this.toolkits.getConnectedAccountInitiationFields(
      toolkit,
      authConfig.auth_scheme
    );
    return connectionParams;
  }
  /**
   * Authorize a user for a toolkit
   * @param {string} serverId - The UUID of the MCP server
   * @param {string} userId - The ID of the user to authorize
   * @param {string} toolkit - The toolkit to authorize
   * @returns {Promise<ConnectionRequest>} Connection request for the toolkit
   */
  async authorize(userId, serverId, toolkit) {
    const mcpServerDetails = await this.get(serverId);
    const authConfigId = mcpServerDetails.authConfigIds?.[0];
    return this.toolkits.authorize(userId, toolkit, authConfigId);
  }
  /**
   * Get server URLs for an existing MCP server
   * @param {string} serverId - Server UUID
   * @param {string} userId - User ID to get server URLs for
   * @param {Object} [options] - Additional options for server configuration
   * @param {string[]} [options.limitTools] - Subset of tools to limit (from MCP config)
   * @param {boolean} [options.isChatAuth] - Whether to use chat-based authentication
   * @returns {Promise<T>} Transformed server URLs in provider-specific format
   *
   * @example
   * ```typescript
   * // Get URLs for an existing server with basic user ID
   * const urls = await composio.mcp.getServer("mcp_xyz", "hey@example.com");
   *
   * // Get URLs with additional options
   * const urls = await composio.mcp.getServer("mcp_xyz", "hey@example.com", {
   *   limitTools: ["GMAIL_FETCH_EMAILS", "SLACK_SEND_MESSAGE"],
   *   isChatAuth: true
   * });
   * ```
   */
  async getServer(serverId, userId, options) {
    const serverDetails = await this.get(serverId);
    if (!userId) {
      throw new ValidationError("User ID is required", {});
    }
    const toolkits = serverDetails.toolkits || [];
    const connectedAccountIds = (await Promise.all(
      toolkits.map(
        (toolkit) => this.client.connectedAccounts.list({
          user_ids: [userId],
          toolkit_slugs: [toolkit],
          statuses: ["ACTIVE"]
        }).then((res) => res.items?.[0]?.id)
      )
    )).filter(Boolean);
    let data;
    try {
      data = await this.client.mcp.generate.url({
        user_ids: [userId],
        // @TODO(utkarsh-dixit): Add support for this later
        connected_account_ids: [],
        mcp_server_id: serverId,
        managed_auth_by_composio: options?.isChatAuth ?? serverDetails.managedAuthViaComposio ?? false
      });
    } catch (error) {
      throw new ValidationError("Failed to generate MCP server URL", {
        cause: error
      });
    }
    const urlResponseResult = ComposioGenerateURLResponseSchema.safeParse(data);
    if (urlResponseResult.error) {
      throw new ValidationError("Failed to parse MCP URL generation response", {
        cause: urlResponseResult.error
      });
    }
    const camelCaseData = transformMcpGenerateUrlResponse(data);
    return this.wrapMcpServerResponse(
      camelCaseData,
      serverDetails.name,
      connectedAccountIds,
      [userId],
      toolkits
    );
  }
  /**
   * List MCP server configurations with filtering options
   * @param {Object} options - Filtering and pagination options
   * @param {number} [options.page] - Page number for pagination
   * @param {number} [options.limit] - Number of items per page
   * @param {string[]} [options.toolkits] - Filter servers by toolkit names
   * @param {string[]} [options.authConfigs] - Filter servers by auth config IDs
   * @param {string} [options.name] - Filter servers by name
   * @param {string} [options.user] - Filter servers by user ID
   * @returns {Promise<McpListResponse>} List of MCP servers matching the filters
   *
   * @example
   * ```typescript
   * // List all servers with pagination
   * const servers = await composio.mcp.list({
   *   page: 1,
   *   limit: 10
   * });
   *
   * // List Gmail and Supabase servers
   * const filteredServers = await composio.mcp.list({
   *   toolkits: ['GMAIL', 'SUPABASE'],
   *   authConfigIds: ['auth_123', 'auth_456']
   * });
   * ```
   */
  async list(options) {
    let listResponse;
    try {
      listResponse = await this.client.mcp.list({
        page_no: options.page || 1,
        limit: options.limit || 10,
        toolkits: options?.toolkits?.join(",") || void 0,
        auth_config_ids: options?.authConfigs?.join(",") || void 0,
        name: options?.name
      });
    } catch (error) {
      throw new ValidationError("Failed to list MCP servers", {
        cause: error
      });
    }
    const listResponseResult = ComposioMcpListResponseSchema.safeParse(listResponse);
    if (listResponseResult.error) {
      throw new ValidationError("Failed to parse MCP server list response", {
        cause: listResponseResult.error
      });
    }
    return transformMcpListResponse(listResponse);
  }
  /**
   * Get details of a specific MCP server
   * @param {string} serverId - Server UUID
   * @returns {Promise<McpRetrieveResponse>} Server details
   *
   * @example
   * ```typescript
   * const serverDetails = await composio.mcp.get('server-uuid');
   * ```
   */
  async get(serverId) {
    let retrieveResponse;
    try {
      retrieveResponse = await this.client.mcp.retrieve(serverId);
    } catch (error) {
      throw new ValidationError("Failed to retrieve MCP server", {
        cause: error
      });
    }
    const retrieveResponseResult = McpRetrieveResponseSchema.safeParse({
      ...retrieveResponse,
      mcpUrl: retrieveResponse.mcp_url
    });
    if (retrieveResponseResult.error) {
      throw new ValidationError("Failed to parse MCP server retrieve response", {
        cause: retrieveResponseResult.error
      });
    }
    return transformMcpRetrieveResponse(retrieveResponse);
  }
  /**
   * Delete an MCP server
   * @param {string} serverId - Server UUID
   * @returns {Promise<McpDeleteResponse>} Deletion response
   *
   * @example
   * ```typescript
   * const result = await composio.mcp.delete('server-uuid');
   * ```
   */
  async delete(serverId) {
    let deleteResponse;
    try {
      deleteResponse = await this.client.mcp.delete(serverId);
    } catch (error) {
      throw new ValidationError("Failed to delete MCP server", {
        cause: error
      });
    }
    const deleteResponseResult = ComposioMcpDeleteResponseSchema.safeParse(deleteResponse);
    if (deleteResponseResult.error) {
      throw new ValidationError("Failed to parse MCP server delete response", {
        cause: deleteResponseResult.error
      });
    }
    return transformMcpDeleteResponse(deleteResponse);
  }
  /**
   * Update an MCP server configuration
   * @param {string} id - Server UUID
   * @param {string} name - New unique name for the server
   * @param {MCPToolkitConfig[]} toolkitConfigs - Array of toolkit configurations
   * @param {MCPAuthOptions} [authOptions] - Updated authentication options
   * @returns {Promise<McpUpdateResponse>} Updated server details
   *
   * @example
   * ```typescript
   * const updatedServer = await composio.mcp.update(
   *   "server-uuid",
   *   "my-updated-server",
   *   [
   *     {
   *       toolkit: "GMAIL",
   *       authConfigId: "ac_sdhkjfhjksdk",
   *       allowedTools: ["GMAIL_FETCH_EMAILS"],
   *     },
   *   ],
   *   {
   *     isChatAuth: true,
   *   }
   * );
   * ```
   */
  async update(serverId, name, toolkitConfigs, authOptions) {
    this.validateInputs(toolkitConfigs, authOptions);
    const toolkits = toolkitConfigs.map((config) => config.toolkit);
    let updateResponse;
    try {
      updateResponse = await this.client.mcp.update(serverId, {
        name,
        toolkits,
        allowed_tools: toolkitConfigs.flatMap((config) => config.allowedTools),
        managed_auth_via_composio: authOptions?.isChatAuth || false
      });
    } catch (error) {
      throw new ValidationError("Failed to update MCP server", {
        cause: error
      });
    }
    const updateResponseResult = ComposioMcpUpdateResponseSchema.safeParse(updateResponse);
    if (updateResponseResult.error) {
      throw new ValidationError("Failed to parse MCP server update response", {
        cause: updateResponseResult.error
      });
    }
    return transformMcpUpdateResponse(updateResponse);
  }
  /**
   * Generate URL for an MCP server
   * @param {string} serverId - Server UUID
   * @param {GenerateURLParams} params - Parameters for URL generation
   * @returns {Promise<GenerateURLResponse>} Generated URL response
   *
   * @example
   * ```typescript
   * const urlResponse = await composio.mcp.generateUrl('server-uuid', {
   *   userIds: ['user123'],
   *   connectedAccountIds: ['account456'],
   *   isChatAuth: true
   * });
   * ```
   */
  async generateUrl(serverId, params) {
    const paramsResult = GenerateURLParamsSchema.safeParse(params);
    if (paramsResult.error) {
      throw new ValidationError("Failed to parse generateUrl parameters", {
        cause: paramsResult.error
      });
    }
    let urlResponse;
    try {
      urlResponse = await this.client.mcp.generate.url({
        mcp_server_id: serverId,
        user_ids: params.userIds,
        connected_account_ids: params.connectedAccountIds,
        managed_auth_by_composio: params.composioManagedAuth
      });
    } catch (error) {
      throw new ValidationError("Failed to generate MCP URL", {
        cause: error
      });
    }
    const responseResult = ComposioGenerateURLResponseSchema.safeParse(urlResponse);
    if (responseResult.error) {
      throw new ValidationError("Failed to parse MCP URL generation response", {
        cause: responseResult.error
      });
    }
    return transformMcpGenerateUrlResponse(urlResponse);
  }
  /**
     * Transform MCP URL response into the appropriate format.
     * If the provider has a custom transform method, use it.
     * Otherwise, use the default transformation.
     *
     * @param data - The MCP URL response data (in camelCase)
     * @param serverName - Name of the MCP server
  
     * @returns Transformed response in appropriate format
     */
  wrapMcpServerResponse(data, serverName, connectedAccountIds, userIds, toolkits) {
    if (this.provider && typeof this.provider.wrapMcpServerResponse === "function") {
      let snakeCaseData;
      if (data.connectedAccountUrls?.length) {
        snakeCaseData = data.connectedAccountUrls.map((url, index) => ({
          name: serverName + "-" + connectedAccountIds?.[index],
          url
        }));
      } else if (data.userIdsUrl?.length) {
        snakeCaseData = data.userIdsUrl.map((url, index) => ({
          name: serverName + "-" + userIds?.[index],
          url
        }));
      } else {
        snakeCaseData = [
          {
            name: serverName,
            url: data.mcpUrl
          }
        ];
      }
      const transformed = this.provider.wrapMcpServerResponse(snakeCaseData);
      return transformed;
    }
    if (connectedAccountIds?.length && data.connectedAccountUrls) {
      return data.connectedAccountUrls.map((url, index) => ({
        url: new URL(url),
        name: `${serverName}-${connectedAccountIds[index]}`,
        toolkit: toolkits?.[index]
      }));
    } else if (userIds?.length && data.userIdsUrl) {
      return data.userIdsUrl.map((url, index) => ({
        url: new URL(url),
        name: `${serverName}-${userIds[index]}`,
        toolkit: toolkits?.[index]
      }));
    }
    return {
      url: new URL(data.mcpUrl),
      name: serverName
    };
  }
  /**
   * Get details of a specific MCP server by name
   * @param {string} name - Server name
   * @returns {Promise<McpRetrieveResponse>} Server details
   * @throws {ValidationError} If no server found with the given name
   * @throws {ValidationError} If multiple servers found with the same name
   *
   * @example
   * ```typescript
   * const serverDetails = await composio.mcp.getByName('my-gmail-server');
   * ```
   */
  async getByName(serverName) {
    if (!serverName) {
      throw new ValidationError("Server name is required", {});
    }
    let listResponse;
    try {
      listResponse = await this.client.mcp.list({
        name: serverName,
        limit: 10
      });
    } catch (error) {
      console.error(error);
      throw new ValidationError("Failed to search MCP servers by name", {
        cause: error
      });
    }
    const listResponseResult = ComposioMcpListResponseSchema.safeParse(listResponse);
    if (listResponseResult.error) {
      throw new ValidationError("Failed to parse MCP server list response", {
        cause: listResponseResult.error
      });
    }
    const servers = listResponse.items || [];
    if (servers.length === 0) {
      throw new ValidationError(`MCP server with name '${serverName}' not found`, {
        meta: { serverName }
      });
    }
    return this.get(servers[0].id);
  }
};

// src/utils/sdk.ts
var userDataPath = () => {
  try {
    const path = require("path");
    const os = require("os");
    return path.join(os.homedir(), COMPOSIO_DIR, USER_DATA_FILE_NAME);
  } catch (_error) {
    logger_default.debug("Environment", `Unable to get user data path`);
    return null;
  }
};
var getUserDataJson = () => {
  try {
    const fs = require("fs");
    const data = fs.readFileSync(userDataPath(), "utf8");
    return JSON.parse(data);
  } catch (_error) {
    logger_default.debug("Environment", "No user data file found");
    return {};
  }
};
function getSDKConfig(baseUrl, apiKey) {
  const userData = getUserDataJson();
  const { api_key: apiKeyFromUserConfig, base_url: baseURLFromUserConfig } = userData;
  const baseURLParsed = baseUrl || getEnvVariable("COMPOSIO_BASE_URL") || baseURLFromUserConfig || DEFAULT_BASE_URL;
  const apiKeyParsed = apiKey || getEnvVariable("COMPOSIO_API_KEY") || apiKeyFromUserConfig || "";
  if (!apiKeyParsed) {
    ComposioError.handle(new ComposioNoAPIKeyError(), {
      exitProcess: true
    });
  }
  logger_default.debug("Environment", `API Key: ${apiKeyParsed}`);
  logger_default.debug("Environment", `Base URL: ${baseURLParsed}`);
  return { baseURL: baseURLParsed, apiKey: apiKeyParsed };
}

// src/utils/version.ts
var import_semver = __toESM(require("semver"), 1);
async function checkForLatestVersionFromNPM(currentVersion) {
  try {
    const packageName = "@composio/core";
    const currentVersionFromPackageJson = currentVersion;
    if (!import_semver.default.valid(currentVersionFromPackageJson)) {
      return;
    }
    const prerelease = import_semver.default.prerelease(currentVersionFromPackageJson);
    if (prerelease && (String(prerelease[0]).includes("alpha") || String(prerelease[0]).includes("beta"))) {
      return;
    }
    const response = await fetch(`https://registry.npmjs.org/${packageName}/latest`);
    const data = await response.json();
    const latestVersion = data.version;
    if (import_semver.default.gt(latestVersion, currentVersionFromPackageJson) && !IS_DEVELOPMENT_OR_CI) {
      logger_default.info(
        `\u{1F680} Upgrade available! Your composio-core version (${currentVersionFromPackageJson}) is behind. Latest version: ${latestVersion}.`
      );
    }
  } catch (_error) {
  }
}

// src/provider/BaseProvider.ts
var BaseProvider = class {
  /**
   * @internal
   * The function to execute a tool.
   * This is set automatically injected by the core SDK.
   */
  _globalExecuteToolFn;
  /**
   * @internal
   * Set the function to execute a tool.
   * This is set automatically and injected by the core SDK.
   */
  _setExecuteToolFn(executeToolFn) {
    this._globalExecuteToolFn = executeToolFn;
  }
  /**
   * @public
   * Global function to execute a tool.
   * This function is used by providerds to implement helper functions to execute tools.
   * This is a 1:1 mapping of the `execute` method in the `Tools` class.
   * @param {string} toolSlug - The slug of the tool to execute.
   * @param {ToolExecuteParams} body - The body of the tool execution.
   * @param {ExecuteToolModifiers} modifers - The modifiers of the tool execution.
   * @returns {Promise<string>} The result of the tool execution.
   */
  executeTool(toolSlug, body, modifers) {
    if (!this._globalExecuteToolFn) {
      throw new ComposioGlobalExecuteToolFnNotSetError("executeToolFn is not set");
    }
    return this._globalExecuteToolFn(toolSlug, body, modifers);
  }
};
var BaseNonAgenticProvider = class extends BaseProvider {
  _isAgentic = false;
};
var BaseAgenticProvider = class extends BaseProvider {
  _isAgentic = true;
};

// src/provider/OpenAIProvider.ts
var OpenAIProvider = class extends BaseNonAgenticProvider {
  name = "openai";
  /**
   * Creates a new instance of the OpenAIProvider.
   *
   * This is the default provider for the Composio SDK and is automatically
   * available without additional installation.
   *
   * @example
   * ```typescript
   * // The OpenAIProvider is used by default when initializing Composio
   * const composio = new Composio({
   *   apiKey: 'your-api-key'
   * });
   *
   * // You can also explicitly specify it
   * const composio = new Composio({
   *   apiKey: 'your-api-key',
   *   provider: new OpenAIProvider()
   * });
   * ```
   */
  constructor() {
    super();
  }
  /**
   * Transform MCP URL response into OpenAI-specific format.
   * OpenAI uses the standard format by default.
   *
   * @param data - The MCP URL response data
   * @returns Standard MCP server response format
   */
  wrapMcpServerResponse(data) {
    return data.map((item) => ({
      url: new URL(item.url),
      name: item.name
    }));
  }
  /**
   * Wraps a Composio tool in the OpenAI function calling format.
   *
   * This method transforms a Composio tool definition into the format
   * expected by OpenAI's function calling API.
   *
   * @param tool - The Composio tool to wrap
   * @returns The wrapped tool in OpenAI format
   *
   * @example
   * ```typescript
   * // Wrap a single tool for use with OpenAI
   * const composioTool = {
   *   slug: 'SEARCH_TOOL',
   *   description: 'Search for information',
   *   inputParameters: {
   *     type: 'object',
   *     properties: {
   *       query: { type: 'string' }
   *     },
   *     required: ['query']
   *   }
   * };
   *
   * const openAITool = provider.wrapTool(composioTool);
   * ```
   */
  wrapTool = (tool) => {
    const formattedSchema = {
      name: tool.slug,
      description: tool.description,
      parameters: tool.inputParameters
    };
    return {
      type: "function",
      function: formattedSchema
    };
  };
  /**
   * Wraps multiple Composio tools in the OpenAI function calling format.
   *
   * This method transforms a list of Composio tools into the format
   * expected by OpenAI's function calling API.
   *
   * @param tools - Array of Composio tools to wrap
   * @returns Array of wrapped tools in OpenAI format
   *
   * @example
   * ```typescript
   * // Wrap multiple tools for use with OpenAI
   * const composioTools = [
   *   {
   *     slug: 'SEARCH_TOOL',
   *     description: 'Search for information',
   *     inputParameters: {
   *       type: 'object',
   *       properties: {
   *         query: { type: 'string' }
   *       }
   *     }
   *   },
   *   {
   *     slug: 'WEATHER_TOOL',
   *     description: 'Get weather information',
   *     inputParameters: {
   *       type: 'object',
   *       properties: {
   *         location: { type: 'string' }
   *       }
   *     }
   *   }
   * ];
   *
   * const openAITools = provider.wrapTools(composioTools);
   * ```
   */
  wrapTools = (tools) => {
    return tools.map((tool) => this.wrapTool(tool));
  };
  /**
   * Executes a tool call from OpenAI's chat completion.
   *
   * This method processes a tool call from OpenAI's chat completion API,
   * executes the corresponding Composio tool, and returns the result.
   *
   * @param {string} userId - The user ID for authentication and tracking
   * @param {OpenAI.ChatCompletionMessageToolCall} tool - The tool call from OpenAI
   * @param {ExecuteToolFnOptions} [options] - Optional execution options
   * @param {ExecuteToolModifiers} [modifiers] - Optional execution modifiers
   * @returns {Promise<string>} The result of the tool call as a JSON string
   *
   * @example
   * ```typescript
   * // Execute a tool call from OpenAI
   * const toolCall = {
   *   id: 'call_abc123',
   *   type: 'function',
   *   function: {
   *     name: 'SEARCH_TOOL',
   *     arguments: '{"query":"composio documentation"}'
   *   }
   * };
   *
   * const result = await provider.executeToolCall(
   *   'user123',
   *   toolCall,
   *   { connectedAccountId: 'conn_xyz456' }
   * );
   * console.log(JSON.parse(result));
   * ```
   */
  async executeToolCall(userId, tool, options, modifiers) {
    const payload = {
      arguments: JSON.parse(tool.function.arguments),
      connectedAccountId: options?.connectedAccountId,
      customAuthParams: options?.customAuthParams,
      customConnectionData: options?.customConnectionData,
      userId
    };
    const result = await this.executeTool(tool.function.name, payload, modifiers);
    return JSON.stringify(result);
  }
  /**
   * Handles tool calls from OpenAI's chat completion response.
   *
   * This method processes tool calls from an OpenAI chat completion response,
   * executes each tool call, and returns the results.
   *
   * @param {string} userId - The user ID for authentication and tracking
   * @param {OpenAI.ChatCompletion} chatCompletion - The chat completion response from OpenAI
   * @param {ExecuteToolFnOptions} [options] - Optional execution options
   * @param {ExecuteToolModifiers} [modifiers] - Optional execution modifiers
   * @returns {Promise<string[]>} Array of tool execution results as JSON strings
   *
   * @example
   * ```typescript
   * // Handle tool calls from a chat completion response
   * const chatCompletion = {
   *   choices: [
   *     {
   *       message: {
   *         tool_calls: [
   *           {
   *             id: 'call_abc123',
   *             type: 'function',
   *             function: {
   *               name: 'SEARCH_TOOL',
   *               arguments: '{"query":"composio documentation"}'
   *             }
   *           }
   *         ]
   *       }
   *     }
   *   ]
   * };
   *
   * const results = await provider.handleToolCalls(
   *   'user123',
   *   chatCompletion,
   *   { connectedAccountId: 'conn_xyz456' }
   * );
   * console.log(results); // Array of tool execution results
   * ```
   */
  async handleToolCalls(userId, chatCompletion, options, modifiers) {
    const outputs = [];
    for (const message of chatCompletion.choices) {
      if (message.message.tool_calls && message.message.tool_calls[0].type === "function") {
        const toolResult = await this.executeToolCall(
          userId,
          message.message.tool_calls[0],
          options,
          modifiers
        );
        outputs.push({
          role: "tool",
          tool_call_id: message.message.tool_calls[0].id,
          content: toolResult
        });
      }
    }
    return outputs;
  }
  /**
   * Handles all the tool calls from the OpenAI Assistant API.
   *
   * This method processes tool calls from an OpenAI Assistant run,
   * executes each tool call, and returns the tool outputs for submission.
   *
   * @deprecated Assistant API is deprecated, please use responses or chat completions instead. This method will be removed in the next major version.
   *
   * @param {string} userId - The user ID for authentication and tracking
   * @param {OpenAI.Beta.Threads.Run} run - The Assistant run object containing tool calls
   * @param {ExecuteToolFnOptions} [options] - Optional execution options
   * @param {ExecuteToolModifiers} [modifiers] - Optional execution modifiers
   * @returns {Promise<OpenAI.Beta.Threads.Runs.RunSubmitToolOutputsParams.ToolOutput[]>} Array of tool outputs for submission
   *
   *
   * @example
   * ```typescript
   * // Handle tool calls from an OpenAI Assistant run
   * const run = {
   *   id: 'run_abc123',
   *   required_action: {
   *     submit_tool_outputs: {
   *       tool_calls: [
   *         {
   *           id: 'call_xyz789',
   *           type: 'function',
   *           function: {
   *             name: 'SEARCH_TOOL',
   *             arguments: '{"query":"composio documentation"}'
   *           }
   *         }
   *       ]
   *     }
   *   }
   * };
   *
   * const toolOutputs = await provider.handleAssistantMessage(
   *   'user123',
   *   run,
   *   { connectedAccountId: 'conn_xyz456' }
   * );
   *
   * // Submit tool outputs back to OpenAI
   * await openai.beta.threads.runs.submitToolOutputs(
   *   thread.id,
   *   run.id,
   *   { tool_outputs: toolOutputs }
   * );
   * ```
   */
  async handleAssistantMessage(userId, run, options, modifiers) {
    const tool_calls = run.required_action?.submit_tool_outputs?.tool_calls || [];
    const tool_outputs = await Promise.all(
      tool_calls.map(async (tool_call) => {
        logger_default.debug(`Executing tool call: ${tool_call.id}`);
        const tool_response = await this.executeToolCall(
          userId,
          tool_call,
          options,
          modifiers
        );
        logger_default.debug(`Tool call ${tool_call.id} executed with response: ${tool_response}`);
        return {
          tool_call_id: tool_call.id,
          output: JSON.stringify(tool_response)
        };
      })
    );
    return tool_outputs;
  }
  /**
   * Waits for the assistant stream and handles the tool calls.
   *
   * This method processes an OpenAI Assistant stream, handles any tool calls
   * that require action, and yields each event from the stream. It's designed
   * for streaming Assistant responses while handling tool calls in real-time.
   *
   * @deprecated Assistant API is deprecated, please use responses or chat completions instead. It will be removed in the next major version.
   *
   * @param {string} userId - The user ID for authentication and tracking
   * @param {OpenAI} client - The OpenAI client instance
   * @param {Stream<OpenAI.Beta.Assistants.AssistantStreamEvent>} runStream - The Assistant run stream
   * @param {OpenAI.Beta.Threads.Thread} thread - The thread object
   * @param {ExecuteToolFnOptions} [options] - Optional execution options
   * @param {ExecuteToolModifiers} [modifiers] - Optional execution modifiers
   * @returns {AsyncGenerator<OpenAI.Beta.Assistants.AssistantStreamEvent, void, unknown>} Generator yielding stream events
   *
   *
   *
   * @example
   * ```typescript
   * // Process an OpenAI Assistant stream with tool calls
   * const thread = await openai.beta.threads.create();
   * const runStream = openai.beta.threads.runs.stream(thread.id, {
   *   assistant_id: 'asst_abc123',
   *   tools: provider.wrapTools(composioTools)
   * });
   *
   * // Process the stream and handle tool calls
   * const streamProcessor = provider.waitAndHandleAssistantStreamToolCalls(
   *   'user123',
   *   openai,
   *   runStream,
   *   thread,
   *   { connectedAccountId: 'conn_xyz456' }
   * );
   *
   * // Consume the stream events
   * for await (const event of streamProcessor) {
   *   if (event.event === 'thread.message.delta') {
   *     console.log(event.data.delta.content);
   *   }
   * }
   * ```
   */
  async *waitAndHandleAssistantStreamToolCalls(userId, client, runStream, thread, options, modifiers) {
    let runId = null;
    for await (const event of runStream) {
      yield event;
      if (event.event === "thread.run.created") {
        const { id } = event.data;
        runId = id;
      }
      if (!runId) {
        continue;
      }
      if (event.event === "thread.run.requires_action") {
        const toolOutputs = await this.handleAssistantMessage(
          userId,
          event.data,
          options,
          modifiers
        );
        await client.beta.threads.runs.submitToolOutputs(runId, {
          thread_id: thread.id,
          tool_outputs: toolOutputs
        });
      }
      if ([
        "thread.run.completed",
        "thread.run.failed",
        "thread.run.cancelled",
        "thread.run.expired"
      ].includes(event.event)) {
        break;
      }
    }
    if (!runId) {
      throw new Error("No run ID found");
    }
    let finalRun = await client.beta.threads.runs.retrieve(runId, {
      thread_id: thread.id
    });
    while (["queued", "in_progress", "requires_action"].includes(finalRun.status)) {
      if (finalRun.status === "requires_action") {
        const toolOutputs = await this.handleAssistantMessage(userId, finalRun, options, modifiers);
        finalRun = await client.beta.threads.runs.submitToolOutputs(runId, {
          thread_id: thread.id,
          tool_outputs: toolOutputs
        });
      } else {
        finalRun = await client.beta.threads.runs.retrieve(runId, {
          thread_id: thread.id
        });
        await new Promise((resolve) => setTimeout(resolve, 500));
      }
    }
  }
  /**
   * Waits for the assistant tool calls and handles them.
   *
   * This method polls an OpenAI Assistant run until it completes or requires action,
   * handles any tool calls, and returns the final run object. It's designed for
   * non-streaming Assistant interactions.
   *
   * @deprecated Assistant API is deprecated, please use responses or chat completions instead. It will be removed in the next major version.
   *
   * @param {string} userId - The user ID for authentication and tracking
   * @param {OpenAI} client - The OpenAI client instance
   * @param {OpenAI.Beta.Threads.Run} run - The initial run object
   * @param {OpenAI.Beta.Threads.Thread} thread - The thread object
   * @param {ExecuteToolFnOptions} [options] - Optional execution options
   * @param {ExecuteToolModifiers} [modifiers] - Optional execution modifiers
   * @returns {Promise<OpenAI.Beta.Threads.Run>} The final run object after completion
   *
   * @example
   * ```typescript
   * // Process an OpenAI Assistant run with tool calls
   * const thread = await openai.beta.threads.create();
   * await openai.beta.threads.messages.create(thread.id, {
   *   role: 'user',
   *   content: 'Find information about Composio'
   * });
   *
   * let run = await openai.beta.threads.runs.create(thread.id, {
   *   assistant_id: 'asst_abc123',
   *   tools: provider.wrapTools(composioTools)
   * });
   *
   * // Wait for the run to complete, handling any tool calls
   * run = await provider.waitAndHandleAssistantToolCalls(
   *   'user123',
   *   openai,
   *   run,
   *   thread,
   *   { connectedAccountId: 'conn_xyz456' }
   * );
   *
   * // Get the final messages after run completion
   * const messages = await openai.beta.threads.messages.list(thread.id);
   * console.log(messages.data[0].content);
   * ```
   */
  async waitAndHandleAssistantToolCalls(userId, client, run, thread, options, modifiers) {
    while (["queued", "in_progress", "requires_action"].includes(run.status)) {
      const tool_outputs = await this.handleAssistantMessage(userId, run, options, modifiers);
      if (run.status === "requires_action") {
        run = await client.beta.threads.runs.submitToolOutputs(run.id, {
          thread_id: thread.id,
          tool_outputs
        });
      } else {
        run = await client.beta.threads.runs.retrieve(run.id, {
          thread_id: thread.id
        });
        await new Promise((resolve) => setTimeout(resolve, 500));
      }
    }
    return run;
  }
};

// package.json
var version = "0.1.48";

// src/models/Files.ts
var Files = class {
  constructor(client) {
    this.client = client;
    telemetry.instrument(this);
  }
  /**
   * Upload a file to S3 and return the file data.
   * @param filePath - The path to the file to upload or a URL of the file to upload.
   * @param toolSlug - The slug of the tool that is uploading the file.
   * @param toolkitSlug - The slug of the toolkit that is uploading the file.
   * @returns The file data.
   */
  async upload({
    file,
    toolSlug,
    toolkitSlug
  }) {
    const fileData = await getFileDataAfterUploadingToS3(file, {
      toolSlug,
      toolkitSlug,
      client: this.client
    });
    return fileData;
  }
  /**
   * Download a file from S3 and return the file data.
   * @param s3key - The S3 key of the file to download.
   * @returns The file data.
   */
  async download({
    toolSlug,
    s3Url,
    mimeType
  }) {
    const fileDownloadData = await downloadFileFromS3({ toolSlug, s3Url, mimeType });
    return fileDownloadData;
  }
};

// src/utils/session.ts
function getSessionHeaders(provider) {
  return {
    "x-source": provider?.name || "@composio/core",
    "x-runtime": "composio-v3-ts-sdk",
    "x-sdk-version": version
  };
}
var getDefaultHeaders = (headers, provider) => {
  const sessionHeaders = getSessionHeaders(provider);
  return {
    ...headers || {},
    ...sessionHeaders
  };
};

// src/composio.ts
var Composio = class _Composio {
  /**
   * The Composio API client.
   * @type {ComposioClient}
   */
  client;
  /**
   * The configuration for the Composio SDK.
   * @type {ComposioConfig<TProvider>}
   */
  config;
  /**
   * Core models for Composio.
   */
  tools;
  toolkits;
  triggers;
  provider;
  files;
  // auth configs
  authConfigs;
  // connected accounts
  connectedAccounts;
  mcp;
  /**
   * Creates a new instance of the Composio SDK.
   *
   * The constructor initializes the SDK with the provided configuration options,
   * sets up the API client, and initializes all core models (tools, toolkits, etc.).
   *
   * @param {ComposioConfig<TProvider>} config - Configuration options for the Composio SDK
   * @param {string} [config.apiKey] - The API key for authenticating with the Composio API
   * @param {string} [config.baseURL] - The base URL for the Composio API (defaults to production URL)
   * @param {boolean} [config.allowTracking=true] - Whether to allow anonymous usage analytics
   * @param {TProvider} [config.provider] - The provider to use for this Composio instance (defaults to OpenAIProvider)
   *
   * @example
   * ```typescript
   * // Initialize with default configuration
   * const composio = new Composio();
   *
   * // Initialize with custom API key and base URL
   * const composio = new Composio({
   *   apiKey: 'your-api-key',
   *   baseURL: 'https://api.composio.dev'
   * });
   *
   * // Initialize with custom provider
   * const composio = new Composio({
   *   apiKey: 'your-api-key',
   *   provider: new CustomProvider()
   * });
   * ```
   */
  constructor(config) {
    const { baseURL: baseURLParsed, apiKey: apiKeyParsed } = getSDKConfig(
      config?.baseURL,
      config?.apiKey
    );
    if (IS_DEVELOPMENT_OR_CI) {
      logger_default.debug(`Initializing Composio w API Key: [REDACTED] and baseURL: ${baseURLParsed}`);
    }
    this.config = {
      ...config,
      allowTracking: config?.allowTracking ?? true
    };
    this.provider = config?.provider ?? new OpenAIProvider();
    const defaultHeaders = getDefaultHeaders(this.config.defaultHeaders, this.provider);
    this.client = new import_client7.default({
      apiKey: apiKeyParsed,
      baseURL: baseURLParsed,
      defaultHeaders,
      logLevel: COMPOSIO_LOG_LEVEL
    });
    this.tools = new Tools(this.client, this.provider, {
      autoUploadDownloadFiles: config?.autoUploadDownloadFiles ?? true
    });
    this.mcp = new MCP(this.client, this.provider);
    this.toolkits = new Toolkits(this.client);
    this.triggers = new Triggers(this.client);
    this.authConfigs = new AuthConfigs(this.client);
    this.files = new Files(this.client);
    this.connectedAccounts = new ConnectedAccounts(this.client);
    if (this.config.allowTracking) {
      telemetry.setup({
        apiKey: apiKeyParsed ?? "",
        baseUrl: baseURLParsed ?? "",
        isAgentic: this.provider?._isAgentic || false,
        version,
        isBrowser: typeof window !== "undefined",
        provider: this.provider?.name ?? "openai",
        host: this.config.host
      });
    }
    telemetry.instrument(this);
    telemetry.instrument(this.provider);
    if (!this.config.disableVersionCheck) {
      checkForLatestVersionFromNPM(version);
    }
  }
  /**
   * Get the Composio SDK client.
   * @returns {ComposioClient} The Composio API client.
   */
  getClient() {
    if (!this.client) {
      throw new Error("Composio client is not initialized. Please initialize it first.");
    }
    return this.client;
  }
  /**
   * Creates a new instance of the Composio SDK with custom request options while preserving the existing configuration.
   * This method is particularly useful when you need to:
   * - Add custom headers for specific requests
   * - Track request contexts with unique identifiers
   * - Override default request behavior for a subset of operations
   *
   * The new instance inherits all configuration from the parent instance (apiKey, baseURL, provider, etc.)
   * but allows you to specify custom request options that will be used for all API calls made through this session.
   *
   * @param {MergedRequestInit} fetchOptions - Custom request options to be used for all API calls in this session.
   *                                          This follows the Fetch API RequestInit interface with additional options.
   * @returns {Composio<TProvider>} A new Composio instance with the custom request options applied.
   *
   * @example
   * ```typescript
   * // Create a base Composio instance
   * const composio = new Composio({
   *   apiKey: 'your-api-key'
   * });
   *
   * // Create a session with request tracking headers
   * const composioWithCustomHeaders = composio.createSession({
   *   headers: {
   *     'x-request-id': '1234567890',
   *     'x-correlation-id': 'session-abc-123',
   *     'x-custom-header': 'custom-value'
   *   }
   * });
   *
   * // Use the session for making API calls with the custom headers
   * await composioWithCustomHeaders.tools.list();
   * ```
   */
  createSession(options) {
    const sessionHeaders = getDefaultHeaders(options?.headers, this.provider);
    return new _Composio({
      ...this.config,
      defaultHeaders: sessionHeaders
    });
  }
};

// src/provider/ComposioProvider.ts
var ComposioProvider = class extends BaseNonAgenticProvider {
  name = "ComposioProvider";
  constructor() {
    super();
  }
  wrapTool = (tool) => {
    return tool;
  };
  wrapTools(tools) {
    return tools.map((tool) => this.wrapTool(tool));
  }
};

// src/utils/jsonSchema.ts
var import_json_schema_to_zod = require("@composio/json-schema-to-zod");
var removeNonRequiredProperties = (schema) => {
  if (schema && schema.type === "object" && schema.required?.length) {
    schema.properties = Object.fromEntries(
      Object.entries(schema.properties || {}).filter(
        ([key]) => schema.required.includes(key)
      )
    );
  }
  schema.additionalProperties = false;
  return schema;
};
function jsonSchemaToZodSchema(jsonSchema, { strict } = {
  strict: false
}) {
  try {
    let schema = jsonSchema;
    if (strict && schema) {
      schema = removeNonRequiredProperties(
        schema
      );
    }
    const zodSchema = (0, import_json_schema_to_zod.jsonSchemaToZod)(schema);
    return zodSchema;
  } catch (error) {
    throw new JsonSchemaToZodError("Failed to convert JSON Schema to Zod Schema", {
      cause: error
    });
  }
}

// src/models/AuthScheme.ts
var AuthScheme = class {
  /**
   * Creates a ConnectionData object for OAuth2 authentication
   * @param params The OAuth2 parameters
   * @returns ConnectionData object
   */
  static OAuth2(params) {
    return {
      authScheme: AuthSchemeTypes.OAUTH2,
      val: {
        status: ConnectionStatuses.INITIALIZING,
        ...params
      }
    };
  }
  /**
   * Creates a ConnectionData object for OAuth1 authentication
   * @param params The OAuth1 parameters
   * @returns ConnectionData object
   */
  static OAuth1(params) {
    return {
      authScheme: AuthSchemeTypes.OAUTH1,
      val: {
        status: ConnectionStatuses.INITIALIZING,
        ...params
      }
    };
  }
  /**
   * Creates a ConnectionData object for Composio Link authentication
   * @returns ConnectionData object
   */
  static ComposioLink(params) {
    return {
      authScheme: AuthSchemeTypes.COMPOSIO_LINK,
      val: {
        status: ConnectionStatuses.INITIALIZING,
        ...params ?? {}
      }
    };
  }
  /**
   * Creates a ConnectionData object for API Key authentication
   * @param params The API key parameters
   * @returns ConnectionData object
   */
  static APIKey(params) {
    return {
      authScheme: AuthSchemeTypes.API_KEY,
      val: {
        status: ConnectionStatuses.ACTIVE,
        ...params
      }
    };
  }
  /**
   * Creates a ConnectionData object for Basic authentication
   * @param params The basic auth parameters
   * @returns ConnectionData object
   */
  static Basic(params) {
    return {
      authScheme: AuthSchemeTypes.BASIC,
      val: {
        status: ConnectionStatuses.ACTIVE,
        ...params
      }
    };
  }
  /**
   * Creates a ConnectionData object for Bearer Token authentication
   * @param params The bearer token parameters
   * @returns ConnectionData object
   */
  static BearerToken(params) {
    return {
      authScheme: AuthSchemeTypes.BEARER_TOKEN,
      val: {
        status: ConnectionStatuses.ACTIVE,
        ...params
      }
    };
  }
  /**
   * Creates a ConnectionData object for Google Service Account authentication
   * @param params The Google service account parameters
   * @returns ConnectionData object
   */
  static GoogleServiceAccount(params) {
    return {
      authScheme: AuthSchemeTypes.GOOGLE_SERVICE_ACCOUNT,
      val: {
        status: ConnectionStatuses.ACTIVE,
        ...params
      }
    };
  }
  /**
   * Creates a ConnectionData object for No Auth authentication
   * @returns ConnectionData object
   */
  static NoAuth(params) {
    return {
      authScheme: AuthSchemeTypes.NO_AUTH,
      val: {
        status: ConnectionStatuses.ACTIVE,
        ...params ?? {}
      }
    };
  }
  /**
   * Creates a ConnectionData object for Basic with JWT authentication
   * @param params The basic with JWT parameters
   * @returns ConnectionData object
   */
  static BasicWithJWT(params) {
    return {
      authScheme: AuthSchemeTypes.BASIC_WITH_JWT,
      val: {
        status: ConnectionStatuses.ACTIVE,
        ...params
      }
    };
  }
  /**
   * Creates a ConnectionData object for Cal.com authentication
   * @returns ConnectionData object
   */
  static CalcomAuth(params) {
    return {
      authScheme: AuthSchemeTypes.CALCOM_AUTH,
      val: {
        status: ConnectionStatuses.ACTIVE,
        ...params ?? {}
      }
    };
  }
  /**
   * Creates a ConnectionData object for Bill.com authentication
   * @param params The Bill.com auth parameters
   * @returns ConnectionData object
   */
  static BillcomAuth(params) {
    return {
      authScheme: AuthSchemeTypes.BILLCOM_AUTH,
      val: {
        status: ConnectionStatuses.ACTIVE,
        ...params
      }
    };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AuthConfigCreationToolAccessConfigSchema,
  AuthConfigErrorCodes,
  AuthConfigListParamsSchema,
  AuthConfigListResponseSchema,
  AuthConfigRetrieveResponseSchema,
  AuthConfigToolAccessConfigSchema,
  AuthConfigTypes,
  AuthConfigUpdateParamsSchema,
  AuthCustomConfigUpdateParamsSchema,
  AuthDefaultConfigUpdateParamsSchema,
  AuthScheme,
  AuthSchemeEnum,
  AuthSchemeTypes,
  BaseAgenticProvider,
  BaseNonAgenticProvider,
  BillcomAuthConnectionDataSchema,
  Composio,
  ComposioAuthConfigNotFoundError,
  ComposioConnectedAccountNotFoundError,
  ComposioCustomCreateResponseSchema,
  ComposioCustomToolsNotInitializedError,
  ComposioError,
  ComposioGenerateURLParamsSchema,
  ComposioGenerateURLResponseSchema,
  ComposioGlobalExecuteToolFnNotSetError,
  ComposioInvalidExecuteFunctionError,
  ComposioInvalidModifierError,
  ComposioLinkConnectionDataSchema,
  ComposioMcpDeleteResponseSchema,
  ComposioMcpListResponseSchema,
  ComposioMcpRetrieveResponseSchema,
  ComposioMcpUpdateResponseSchema,
  ComposioMultipleConnectedAccountsError,
  ComposioNoAPIKeyError,
  ComposioProvider,
  ComposioProviderNotDefinedError,
  ComposioToolExecutionError,
  ComposioToolNotFoundError,
  ComposioToolkitFetchError,
  ComposioToolkitNotFoundError,
  ConnectedAccountAuthConfigSchema,
  ConnectedAccountErrorCodes,
  ConnectedAccountListParamsSchema,
  ConnectedAccountListResponseSchema,
  ConnectedAccountRetrieveResponseSchema,
  ConnectedAccountStatusSchema,
  ConnectedAccountStatuses,
  ConnectionDataSchema,
  ConnectionRequestErrorCodes,
  ConnectionRequestFailedError,
  ConnectionRequestTimeoutError,
  ConnectionStatus,
  ConnectionStatuses,
  CreateAuthConfigParamsSchema,
  CreateAuthConfigResponseSchema,
  CreateComposioManagedAuthConfigParamsSchema,
  CreateConnectedAccountOptionsSchema,
  CreateConnectedAccountParamsSchema,
  CreateConnectedAccountResponseSchema,
  CreateCustomAuthConfigParamsSchema,
  CustomAuthParamsSchema,
  CustomConnectionDataSchema,
  CustomCreateResponseSchema,
  CustomOauth1ConnectionDataSchema,
  CustomOauth2ConnectionDataSchema,
  DefaultCreateConnectedAccountParamsSchema,
  GenerateURLParamsSchema,
  GenerateURLResponseSchema,
  IncomingTriggerPayloadSchema,
  JSONSchemaPropertySchema,
  JsonSchemaToZodError,
  MCP,
  MCPAuthOptionsSchema,
  MCPGenerateURLParamsSchema,
  MCPGetServerParamsSchema,
  MCPMultiAppServerSchema,
  MCPServerCreateResponseSchema,
  MCPServerListResponseSchema,
  MCPServerSchema,
  MCPServerUpdateParamsSchema,
  MCPSingleAppServerSchema,
  MCPToolkitConfigSchema,
  MCPToolkitConfigsArraySchema,
  McpDeleteResponseSchema,
  McpListResponseSchema,
  McpRetrieveResponseSchema,
  McpUpdateResponseSchema,
  Oauth1ActiveConnectionDataSchema,
  Oauth1ConnectionDataSchema,
  Oauth1ExpiredConnectionDataSchema,
  Oauth1FailedConnectionDataSchema,
  Oauth1InactiveConnectionDataSchema,
  Oauth1InitiatedConnectionDataSchema,
  Oauth1InitiatingConnectionDataSchema,
  Oauth2ActiveConnectionDataSchema,
  Oauth2ConnectionDataSchema,
  Oauth2ExpiredConnectionDataSchema,
  Oauth2FailedConnectionDataSchema,
  Oauth2InactiveConnectionDataSchema,
  Oauth2InitiatedConnectionDataSchema,
  Oauth2InitiatingConnectionDataSchema,
  OpenAIProvider,
  RedirectableAuthSchemeSchema,
  SDKErrorCodes,
  ToolErrorCodes,
  ToolExecuteParamsSchema,
  ToolExecuteResponseSchema,
  ToolKitItemSchema,
  ToolKitListResponseSchema,
  ToolKitMetaSchema,
  ToolListParamsSchema,
  ToolListResponseSchema,
  ToolProxyParamsSchema,
  ToolSchema,
  ToolkitAuthConfigDetailsSchema,
  ToolkitAuthFieldSchema,
  ToolkitAuthFieldsResponseSchema,
  ToolkitCategorySchema,
  ToolkitErrorCodes,
  ToolkitMangedByEnumSchema,
  ToolkitRetrieveCategoriesResponseSchema,
  ToolkitRetrieveResponseSchema,
  ToolkitSchema,
  ToolkitSortByEnumSchema,
  ToolkitsListParamsSchema,
  TriggerInstanceListActiveParamsSchema,
  TriggerInstanceListActiveResponseItemSchema,
  TriggerInstanceListActiveResponseSchema,
  TriggerInstanceManageDeleteResponseSchema,
  TriggerInstanceManageUpdateParamsSchema,
  TriggerInstanceManageUpdateResponseSchema,
  TriggerInstanceUpsertParamsSchema,
  TriggerInstanceUpsertResponseSchema,
  TriggerStatusEnum,
  TriggerStatuses,
  TriggerSubscribeParamSchema,
  TriggerTypeSchema,
  TriggersTypeListParamsSchema,
  TriggersTypeListResponseSchema,
  ValidationError,
  ValidationErrorCodes,
  constants,
  createConnectionRequest,
  jsonSchemaToZodSchema,
  logger,
  removeNonRequiredProperties
});
